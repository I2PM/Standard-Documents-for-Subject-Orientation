
%appendix in smaller font size
\footnotesize

\section{Conceptual Differences ASM Semantic / OWL Model}

% Some content might move to Appendix B / replace it.

This implementation provides more language elements than covered by the OWL description and also gives some concrete implementations.

Additionally to OWL:
\begin{itemize}
    \item Internal Behavior: usage of Subject Data: DataModificationFunction (VarMan: Selection, Concatenation, \ldots), DataMappingFunction (StoreMessage, UseMessageContent, UseCorrelationID).
    Subject Data can be scoped to Macro Instance.
    \item Interaction: Subject Restart, Inputpool Functions (CloseIP, OpenIP, \ldots), CorrelationID, Mobility of Channel.
\end{itemize}

There are also some conceptional differences and limitations:
\begin{itemize}
    \item only blocking asynchronous send, i.e. IP strategy blocking - no delete / drop. no sync send.
    \item modal split / join instead of ChoiceSegement. only mandatory to start and end / no optional start or optional end.
    \item timeout transitions: designed for interactive validation -> duration in seconds, no business days. also no reminders.
    \item Observer: different approach: no native support; possible via Modal Split + Receive State with State Priority + following Cancel Function
\end{itemize}



\newpage
\section{Actual Appendix}

\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
function channelFor : Agents -> LIST

derived processIDFor(a)       = processIDOf(channelFor(a))
derived processInstanceFor(a) = processInstanceOf(channelFor(a))
derived subjectIDFor(a)       = subjectIDOf(channelFor(a))
derived agentFor(a)           = agentOf(channelFor(a))

derived processIDOf(ch)       = nth(ch, 1)
derived processInstanceOf(ch) = nth(ch, 2)
derived subjectIDOf(ch)       = nth(ch, 3)
derived agentOf(ch)           = nth(ch, 4)
\end{minted}
\caption{channelFor}
\label{lst:asm:channelFor}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel -> List[List[MI, StateNumber]]
function killStates : LIST -> LIST

// Channel * macroInstanceNumber -> List[StateNumber]
function activeStates : LIST * NUMBER -> LIST
\end{minted}
\caption{activeStates}
\label{lst:asm:activeStates}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function initializedState : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function completed : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber
function timeoutActive  : LIST * NUMBER * NUMBER -> BOOLEAN
function cancelDecision : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function abortionCompleted : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber -> ..
function selectedTransition : LIST * NUMBER * NUMBER -> NUMBER // -> TransitionNumber
function initializedSelectedTransition : LIST * NUMBER * NUMBER -> BOOLEAN
function startTime  : LIST * NUMBER * NUMBER -> NUMBER

// can exit
// Channel * MacroInstanceNumber * TransitionNumber -> BOOLEAN
function exitCondition : LIST * NUMBER * NUMBER -> BOOLEAN
// TODO: may rename, possibly transitionEnabled ???

// Channel * MacroInstanceNumber * TransitionNumber -> BOOLEAN
function transitionCompleted : LIST * NUMBER * NUMBER -> BOOLEAN
\end{minted}
\caption{initializedState}
\label{lst:asm:initializedState}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
derived shouldTimeout(ch, MI, stateNumber) = return boolres in {
  let pID = processIDOf(ch) in {
    if (hasTimeoutTransition(pID, stateNumber) = true and startTime(ch, MI, stateNumber) != undef) then {
      let transitionNumber = first_outgoingTimeoutTransition(pID, stateNumber) in
      let timeout = transitionTimeout(pID, transitionNumber) * 1000 * 1000 * 1000 in {
        let runningTime = (nanoTime() - startTime(ch, MI, stateNumber)) in
          boolres := (runningTime > timeout)
      }
    }
    else {
      boolres := false
    }
  }
}
\end{minted}
\caption{shouldTimeout}
\label{lst:asm:shouldTimeout}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * macroInstanceNumber * varname -> [vartype, content]
function variable : LIST * NUMBER * STRING -> LIST

// Channel -> Set[(macroInstanceNumber, varname)]
function variableDefined : LIST -> SET
\end{minted}
\caption{variable}
\label{lst:asm:variable}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// receiverChannel * senderSubjID * messageType * correlationID -> [msg1, msg2, ...]
function inputPool : LIST * STRING * STRING * NUMBER -> LIST

/* store all locations where an inputPool was defined for to allow IPEmpty and receiving from "?" */
// receiverChannel -> {[senderSubjID, messageType, correlationID], ..}
function inputPoolDefined : LIST -> SET
\end{minted}
\caption{inputPool}
\label{lst:asm:inputPool}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * StateNumber -> Set[Messages]
function receivedMessages : LIST * NUMBER * NUMBER -> SET

// Channel * MacroInstanceNumber * StateNumber -> Set[Channel]
function receivers : LIST * NUMBER * NUMBER -> SET

// Channel * MacroInstanceNumber * StateNumber -> STRING
function messageContent : LIST * NUMBER * NUMBER -> LIST

// Channel * MacroInstanceNumber * StateNumber -> Set[Channel]
function reservationsDone : LIST * NUMBER * NUMBER -> SET
\end{minted}
\caption{receivedMessages}
\label{lst:asm:receivedMessages}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * macroInstanceNumber -> result
function macroTerminationResult : LIST * NUMBER -> ELEMENT

// Channel * macroInstanceNumber -> MacroNumber
function macroNumberOfMI : LIST * NUMBER -> NUMBER

// Channel * macroInstanceNumber * StateNumber -> MacroInstance
function callMacroChildInstance : LIST * NUMBER * NUMBER -> NUMBER
\end{minted}
\caption{macroTerminationResult}
\label{lst:asm:macroTerminationResult}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// called form PerformEnd (iff other states are active) and AbortCallMacro
rule AbortMacroInstance(MIAbort, ignoreState) = {
  foreach currentState in activeStates(channelFor(self), MIAbort) do {
    add [MIAbort, currentState] to killStates(channelFor(self))
  }

  ClearAllVarInMIForChannel(channelFor(self), MIAbort)
}
\end{minted}
\caption{AbortMacroInstance}
\label{lst:asm:AbortMacroInstance}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartASMAgent(ch) = {
  extend Agents with a do seqblock
    channelFor(a) := ch

    add a to asmAgents

    program(a) := @StartMainMacro
  endseqblock
}
\end{minted}
\caption{StartASMAgent}
\label{lst:asm:StartASMAgent}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small,escapeinside=~~]{lexer.py:CoreASMLexer -x}
rule StartMainMacro = {
  let ch = channelFor(self) in {
    killStates(ch) := []

    variableDefined(ch) := {[0, "$self"], [0, "$empty"]}
    variable(ch, 0, "$self") := ["ChannelInformation", {ch}]
    variable(ch, 0, "$empty") := ["Text", ""]
  }

  let mID  = subjectMainMacro(processIDFor(self), subjectIDFor(self)) in
  let startState = macroStartState(processIDFor(self), mID) in
  let MI   = 1 in // 0 reserved for top-level variable manipulation; 1 mainmacro
  {
    macroNumberOfMI(channelFor(self), MI) := mID

    nextMacroInstanceNumber(channelFor(self)) := MI  + 1

    activeStates(channelFor(self), MI) := [startState]
  }

  program(self) := @SubjectBehavior
}
\end{minted}
\caption{StartMainMacro}
\label{lst:asm:StartMainMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartMacro(MI, currentStateNumber, mIDNew, MINew) = {
  let pID = processIDFor(self) in
  let startState = macroStartState(pID, mIDNew) in {
    activeStates(channelFor(self), MINew) := []
    AddState(MI, currentStateNumber, MINew, startState)
  }
}
\end{minted}
\caption{StartMacro}
\label{lst:asm:StartMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
/*
0 - REPEAT
  -* Behavior should be executed again for this state
  -* results of previous execution will be merged with following execution in one global ASM step
  -* no other states are allowed to be executed
1 - DONE
  -* no other active states are allowed to be executed
  -* new states are started
  -* global ASM / LTS step should be done
2 - NEXT
  -* nothing changed / waiting for input
  -* other active states with the same priority can be executed
  -* active states with lower priority can not be executed
3 - LOWER
  -* nothing changed / waiting for input
  -* other active states, even with lower priority, can be executed
*/

// ch * MacroInstanceNumber * stateNumber => Int
function executionState : LIST * NUMBER * NUMBER -> NUMBER


/*
1 - DONE
2 - NEXT
3 - LOWER
*/
// ch * MacroInstanceNumber => Int
function macroExecutionState : LIST * NUMBER -> NUMBER

// ch * MacroInstanceNumber * stateNumber => List[(MI, s)]
function addStates : LIST * NUMBER * NUMBER -> LIST

// ch * MacroInstanceNumber * stateNumber => List[(MI, s)]
function removeStates : LIST * NUMBER * NUMBER -> LIST
\end{minted}
\caption{SetExecutionState}
\label{lst:asm:SetExecutionState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AddState(MI, currentStateNumber, MINew, sNew) = {
  add [MINew, sNew] to addStates(channelFor(self), MI, currentStateNumber)
}

rule RemoveState(MI, currentStateNumber, MIOld, sOld) = {
  add [MIOld, sOld] to removeStates(channelFor(self), MI, currentStateNumber)
}
\end{minted}
\caption{AddState}
\label{lst:asm:AddState}
\end{listing}







\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SubjectBehavior = {
  choose x in killStates(channelFor(self)) do {
    KillBehavior(nth(x, 1), nth(x, 2))
  }
  ifnone seqblock
    MacroBehavior(1)

    // reset
    macroExecutionState(channelFor(self), 1) := undef
  endseqblock
}
\end{minted}
\caption{SubjectBehavior}
\label{lst:asm:SubjectBehavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule KillBehavior(MI, currentStateNumber) =
 let s = currentStateNumber,
    ch = channelFor(self) in
  if (initializedState(ch, MI, s) != true) then {
    remove [MI, s] from killStates(ch)
    remove n from activeStates(ch, MI)
  }
  else seqblock
    executionState(ch, MI, s) := undef
    addStates(ch, MI, s)       := []
    removeStates(ch, MI, s)    := []

    if (abortionCompleted(ch, MI, s) != true) then
      Abort(MI, s)
    else {
      RemoveState(MI, s, MI, s)
      SetExecutionState(MI, s, DONE)
    }

    if (executionState(ch, MI, s) != 1) then {
      Crash()
    }
    else if (|addStates(ch, MI, s)| > 0) then {
      Crash()
    }
    else if (|removeStates(ch, MI, s)| > 0) then {
      if (removeStates(ch, MI, s) != [[MI, s]]) then {
        Crash()
      }
      else {
        foreach x in removeStates(ch, MI, s) do {
          let xMI = nth(x, 1),
            xN  = nth(x, 2) in {
            remove [xMI, xN] from killStates(ch)
            ResetState(xMI, xN)
            remove xN from activeStates(ch, xMI)
          }
        }
      }
    }
  endseqblock
\end{minted}
\caption{KillBehavior}
\label{lst:asm:KillBehavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule MacroBehavior(MI) =
  let ch = channelFor(self),
     pID = processIDFor(self) in
  local remainingStates := activeStates(ch, MI) in
    seq
      macroExecutionState(ch, MI) := undef
    next
      // NOTE: can not be done with foreach, as remainingStates is modified
      while (|remainingStates| > 0) do
      let stateNumber = getAnyStateWithHighestPrio(pID, remainingStates) in
      seqblock
        executionState(ch, MI, stateNumber) := undef
        addStates(ch, MI, stateNumber)      := []
        removeStates(ch, MI, stateNumber)   := []

        Behavior(MI, stateNumber)

        // NOTE: mutates remainingStates!
        let state = executionState(ch, MI, stateNumber) in
          UpdateRemainingStates(MI, stateNumber, state, remainingStates)

        UpdateActiveStates(MI, stateNumber)
      endseqblock
\end{minted}
\caption{MacroBehavior}
\label{lst:asm:MacroBehavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule UpdateRemainingStates(MI, stateNumber, exState, remainingStates) =
  let ch = channelFor(self),
     pID = processIDFor(self) in
  if (exState = REPEAT) then {
    remainingStates := [stateNumber]

    macroExecutionState(ch, MI) := DONE

    // reset
    executionState(ch, MI, stateNumber) := undef
  }
  else if (exState = DONE) then {
    seq // end loop ...
      remainingStates := []
    next
      // ... but add new states of this MI to initialize them,
      // so that all states have the same start time
      foreach x in addStates(ch, MI, stateNumber)
        with nth(x, 1) = MI do {
        add nth(x, 2) to remainingStates
      }

    macroExecutionState(ch, MI) := DONE

    // quasi-reset
    executionState(ch, MI, stateNumber) := NEXT
  }
  else if (exState = NEXT) then {
    seq
      remove stateNumber from remainingStates // remove self
    next
      // reduce to states with same priority
      let prio = statePriority(pID, stateNumber) in
        remainingStates := filterStatesWithSamePrio(pID, remainingStates, prio)

    if (macroExecutionState(ch, MI) != DONE) then
      macroExecutionState(ch, MI) := NEXT
  }
  else if (exState = LOWER) then {
    remove stateNumber from remainingStates // remove self

    if (macroExecutionState(ch, MI) != DONE
        and macroExecutionState(ch, MI) != NEXT) then
      macroExecutionState(ch, MI) := LOWER
  }
\end{minted}
\caption{UpdateRemainingStates}
\label{lst:asm:UpdateRemainingStates}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule UpdateActiveStates(MI, stateNumber) =
  // NOTE: everything needs to be sequential,
  // as activeStates is a list and not a set
  let ch = channelFor(self) in seqblock
    foreach x in addStates(ch, MI, stateNumber) do
      let xMI = nth(x, 1),
          xN  = nth(x, 2) in {
        add xN to activeStates(ch, xMI)
      }

    addStates(ch, MI, stateNumber) := undef

    foreach x in removeStates(ch, MI, stateNumber) do
      let xMI = nth(x, 1),
          xN  = nth(x, 2) in {
        // remove one instance of xN, if any
        remove xN from activeStates(ch, xMI)

        ResetState(xMI, xN)
      }

    removeStates(ch, MI, stateNumber) := undef
  endseqblock
\end{minted}
\caption{UpdateActiveStates}
\label{lst:asm:UpdateActiveStates}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// whether the state should be aborted or not
derived abortState(MI, stateNumber) =
  ((timeoutActive(channelFor(self), MI, stateNumber) = true) or
  (cancelDecision(channelFor(self), MI, stateNumber) = true))
\end{minted}
\caption{abortState}
\label{lst:asm:abortState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Behavior(MI, currentStateNumber) =
 let s = currentStateNumber,
    ch = channelFor(self) in
  if (initializedState(ch, MI, s) != true) then
    StartState(MI, s)
  else if (abortState(MI, s) = true) then
    AbortState(MI, s)
  else if (completed(ch, MI, s) != true) then
    Perform(MI, s)
  else if (initializedSelectedTransition(ch, MI, s) != true) then
    StartSelectedTransition(MI, s)
  else
   let transitionNumber = selectedTransition(ch, MI, s) in
    if (transitionCompleted(ch, MI, t) != true) then
      PerformTransition(MI, s, t)
    else {
      Proceed(MI, s, targetStateNumber(processIDFor(self), t))
      SetExecutionState(MI, s, DONE)
    }
\end{minted}
\caption{Behavior}
\label{lst:asm:Behavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortState(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  if (abortionCompleted(ch, MI, s) != true) then
    Abort(MI, s)
  else {
    if (cancelDecision(ch, MI, s) = true) then {
      let t = first_outgoingCancelTransition(pID, s) in
      let target = targetStateNumber(pID, t) in {
        Proceed(MI, s, target)
      }
    }
    else if (timeoutActive(ch, MI, s) = true) then {
      let t = first_outgoingTimeoutTransition(pID, s) in
      let target = targetStateNumber(pID, t) in {
        Proceed(MI, s, target)
      }
    }

    SetExecutionState(MI, s, DONE)
  }
\end{minted}
\caption{AbortState}
\label{lst:asm:AbortState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartState(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  let sType     = stateType(pID, s) in seqblock
    InitializeCompletion(MI, s)
    abortionCompleted(ch, MI, s) := false

    ResetTimeout(MI, s)
    cancelDecision(ch, MI, s) := false

    DisableAllTransitions(MI, s)
    initializedSelectedTransition(ch, MI, s) := false

    wantInput(ch, MI, s) := {}

    case sType of
      "function"       : StartFunction(MI, s)
      "internalAction" : StartInternalAction(MI, s)
      "send"           : StartSend(MI, s)
      "receive"        : SetExecutionState(MI, s, LOWER)
      "end"            : StartEnd(MI, s)
    endcase

    initializedState(ch, MI, s) := true
  endseqblock
\end{minted}
\caption{StartState}
\label{lst:asm:StartState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ResetState(MI, stateNumber) =
  let ch = channelFor(self),
       s = stateNumber in {
    executionState(ch, MI, s) := undef

    initializedState(ch, MI, s) := undef

    completed(ch, MI, s) := undef
    abortionCompleted(ch, MI, s) := undef

    startTime(ch, MI, s) := undef
    timeoutActive(ch, MI, s) := undef

    cancelDecision(ch, MI, s) := undef

    selectedTransition(ch, MI, s) := undef

    let pID = processIDFor(self) in
    forall t in outgoingNormalTransitions(pID, s) do {
      exitCondition(ch, MI, t) := undef
      transitionCompleted(ch, MI, t) := undef
    }

    initializedSelectedTransition(ch, MI, s) := undef

    wantInput(ch, MI, s) := undef

    // StartSend
    receivers(ch, MI, s) := undef
    reservationsDone(ch, MI, s) := undef
    messageContent(ch, MI, s) := undef
  }
\end{minted}
\caption{ResetState}
\label{lst:asm:ResetState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Perform(MI, currentStateNumber) =
  let pID = processIDFor(self)
        s = currentStateNumber in
  case stateType(pID, s) of
    "function"       : PerformFunction(MI, s)
    "internalAction" : PerformInternalAction(MI, s)
    "send"           : PerformSend(MI, s)
    "receive"        : PerformReceive(MI, s)
    "end"            : PerformEnd(MI, s)
  endcase
\end{minted}
\caption{Perform}
\label{lst:asm:Perform}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartSelectedTransition(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    let t = selectedTransition(ch, MI, s) in {
      InitializeCompletionTransition(MI, t)
      initializedSelectedTransition(ch, MI, s) := true
    }

    SetExecutionState(MI, s, REPEAT)
  }
\end{minted}
\caption{StartSelectedTransition}
\label{lst:asm:StartSelectedTransition}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Proceed(MI, s_from, s_to) = {
  AddState(MI, s_from, MI, s_to)
  RemoveState(MI, s_from, MI, s_from)
}
\end{minted}
\caption{Proceed}
\label{lst:asm:Proceed}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartTimeout(MI, currentStateNumber) = {
  startTime(channelFor(self), MI, currentStateNumber) := nanoTime()
  timeoutActive(channelFor(self), MI, currentStateNumber) := false
}

rule ResetTimeout(MI, currentStateNumber) = {
  startTime(channelFor(self), MI, currentStateNumber) := undef
  timeoutActive(channelFor(self), MI, currentStateNumber) := undef
}

rule ActivateTimeout(MI, currentStateNumber) = {
  timeoutActive(channelFor(self), MI, currentStateNumber) := true
}

rule InitializeCompletion(MI, currentStateNumber) = {
  completed(channelFor(self), MI, currentStateNumber) := false
}

rule SetCompleted(MI, currentStateNumber) = {
  SetExecutionState(MI, currentStateNumber, REPEAT)
  completed(channelFor(self), MI, currentStateNumber) := true
}

rule SetAbortionCompleted(MI, currentStateNumber) = {
  SetExecutionState(MI, currentStateNumber, DONE)
  abortionCompleted(channelFor(self), MI, currentStateNumber) := true
}


rule EnableTransition(MI, t) = {
  exitCondition(channelFor(self), MI, t) := true
}

rule EnableAllTransitions(MI, currentStateNumber) = {
  forall t in outgoingNormalTransitions(processIDFor(self), currentStateNumber) do {
    EnableTransition(MI, t)
  }
}


rule DisableTransition(MI, currentStateNumber, t) = {
  exitCondition(channelFor(self), MI, t) := false
}

rule DisableAllTransitions(MI, currentStateNumber) = {
  selectedTransition(channelFor(self), MI, currentStateNumber) := undef

  forall t in outgoingNormalTransitions(processIDFor(self), currentStateNumber) do {
    DisableTransition(MI, currentStateNumber, t)
  }
}

rule InitializeCompletionTransition(MI, t) = {
  transitionCompleted(channelFor(self), MI, t) := false
}


rule SetCompletedTransition(MI, currentStateNumber, t) = {
  SetExecutionState(MI, currentStateNumber, REPEAT)

  transitionCompleted(channelFor(self), MI, t) := true
}
\end{minted}
\caption{StartTimeout}
\label{lst:asm:StartTimeout}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartInternalAction(MI, currentStateNumber) = {
  StartTimeout(MI, currentStateNumber)

  EnableAllTransitions(MI, currentStateNumber)

  SetExecutionState(MI, currentStateNumber, LOWER)
}
\end{minted}
\caption{StartInternalAction}
\label{lst:asm:StartInternalAction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformInternalAction(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
    if (shouldTimeout(ch, MI, s) = true) then {
      SetCompleted(MI, s)
      ActivateTimeout(MI, s)
    }
    else if (selectedTransition(ch, MI, s) != undef) then
      SetCompleted(MI, s)
    else
      SelectTransition(MI, s)
\end{minted}
\caption{PerformInternalAction}
\label{lst:asm:PerformInternalAction}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartFunction(MI, currentStateNumber) =
  let pID = processIDFor(self) in
  let functionName = stateFunction(pID, currentStateNumber) in {
    StartTimeout(MI, currentStateNumber)

    if (startFunction(functionName) = undef) then
      skip
    else
      call startFunction(functionName) (MI, currentStateNumber)

    SetExecutionState(MI, currentStateNumber, LOWER)
  }
\end{minted}
\caption{StartFunction}
\label{lst:asm:StartFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformFunction(MI, currentStateNumber) =
  let s = currentStateNumber in
    if (shouldTimeout(channelFor(self), MI, s) = true) then {
      SetCompleted(MI, s)
      ActivateTimeout(MI, s)
    }
    else
      let pID = processIDFor(self) in
      let functionName = stateFunction(pID, s),
          args         = stateFunctionArguments(pID, s) in
        call performFunction(functionName) (MI, s, args)
\end{minted}
\caption{PerformFunction}
\label{lst:asm:PerformFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortFunction(MI, currentStateNumber) =
  let pID = processIDFor(self) in
  let functionName = stateFunction(pID, currentStateNumber) in
    if (abortFunction(functionName) = undef) then
      SetAbortionCompleted(MI, currentStateNumber)
    else
      // must set abortionCompleted eventually
      call abortFunction(functionName) (MI, currentStateNumber)
\end{minted}
\caption{AbortFunction}
\label{lst:asm:AbortFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionFunction(MI, currentStateNumber, t) =
  let pID = processIDFor(self),
        s = currentStateNumber in
  let functionName = stateFunction(pID, s) in
    if (performTransitionFunction(functionName) = undef) then
      SetCompletedTransition(MI, s, t)
    else
      call performTransitionFunction(functionName) (MI, s, t)
\end{minted}
\caption{PerformTransitionFunction}
\label{lst:asm:PerformTransitionFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SetCompletedAction(MI, currentStateNumber, res) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    if (res = undef) then
      choose t in outgoingNormalTransitions(pID, s) do
        selectedTransition(ch, MI, s) := t
    else
      let t = getTransitionByLabel(pID, s, res) in
        selectedTransition(ch, MI, s) := t

    SetCompleted(MI, s)
  }
\end{minted}
\caption{SetCompletedAction}
\label{lst:asm:SetCompletedAction}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartSend(MI, currentStateNumber) = {
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  // there must be exactly one transition
  let  t = first_outgoingNormalTransition(pID, s) in {
    receivers(ch, MI, s) := undef
    reservationsDone(ch, MI, s) := {}
    let mcVName = messageContentVar(pID, t) in
      messageContent(ch, MI, s) := loadVar(MI, mcVName)

    let cIDVName = messageNewCorrelationVar(pID, t) in
      if (cIDVName != undef and cIDVName != "") then {
        // FIXME: it's a bad idea to save the cID early and read
        // this variable later: it might get changed in the meantime
        SetVar(MI, cIDVName, "CorrelationID", nextCorrelationID)

        nextCorrelationID := nextCorrelationID + 1
        // ensure no other agent increments nextCorrelationID
        nextCorrelationIDUsedBy(nextCorrelationID) := self
      }
  }

  SetExecutionState(MI, s, LOWER)
}
\end{minted}
\caption{StartSend}
\label{lst:asm:StartSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformSend(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
  if (receivers(ch, MI, s) = undef) then
    SelectReceivers(MI, s)
  else if (messageContent(ch, MI, s) = undef) then
    SetMessageContent(MI, s)
  else if (startTime(ch, MI, s) = undef) then {
    StartTimeout(MI, s)
    SetExecutionState(MI, s, REPEAT)
  }
  else if (|receivers(ch, MI, s)| =
           |reservationsDone(ch, MI, s)|) then
    TryCompletePerformSend(MI, s)
  else if (shouldTimeout(ch, MI, s) = true) then {
    SetCompleted(MI, s)
    ActivateTimeout(MI, s)
  }
  else
    DoReservations(MI, s)
\end{minted}
\caption{PerformSend}
\label{lst:asm:PerformSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule TryCompletePerformSend(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  if (anyNonProperTerminated(receivers(ch, MI, s)) = true) then
    // BLOCKED: a receiver where a reservation was placed has
    // terminated non-proper in the meantime, refusing to continue
    if (shouldTimeout(ch, MI, s) = true) then {
      SetCompleted(MI, s)
      ActivateTimeout(MI, s)
    }
    else
      SetExecutionState(MI, s, NEXT)
  else {
    // there must be exactly one transition
    let t = first_outgoingNormalTransition(pID, s) in
      selectedTransition(ch, MI, s) := t

    SetCompleted(MI, s)
  }
\end{minted}
\caption{TryCompletePerformSend}
\label{lst:asm:TryCompletePerformSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectReceivers(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  // there must be exactly one transition
  let t = first_outgoingNormalTransition(pID, s) in
  let min = messageSubjectCountMin(pID, t),   // 0 => ALL
      max = messageSubjectCountMax(pID, t) in // 0 => no limit
    let recVName = messageSubjectVar(pID, t) in
    if (recVName != undef and recVName != "") then
      let rChs = loadChannelsFromVariable(MI, recVName, messageSubjectId(pID, t)) in
        if (|rChs| = 0 or (min != 0 and |rChs| < min)) then
          // BLOCKED: not enough receivers given
          SetExecutionState(MI, s, NEXT)
        else if (max != 0 and |rChs| > max)  then
          // too many receivers given -> call VarMan-Selection
          SelectReceivers_Selection(MI, s, rChs, min, max)
        else {
          // receivers fit min/max -> use them
          receivers(ch, MI, s) := rChs
          SetExecutionState(MI, s, REPEAT)
        }
    else // no variable with receivers -> call SelectAgents
      if (selectAgentsResult(ch, MI, s) != undef) then
        let y = selectAgentsResult(ch, MI, s) in {
          receivers(ch, MI, s) := y
          selectAgentsResult(ch, MI, s) := undef // reset

          SetExecutionState(MI, s, REPEAT)
        }
      else
        let sIDLocal = messageSubjectId(pID, t) in
          SelectAgents(MI, s, sIDLocal, min, max)
\end{minted}
\caption{SelectReceivers}
\label{lst:asm:SelectReceivers}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectReceivers_Selection(MI, currentStateNumber, rChs, min, max) =
  let ch = channelFor(self),
       s = currentStateNumber in
  let res = selectionResult(ch, MI, s) in
  if (res = undef) then
    let src = ["ChannelInformation", rChs] in
      Selection(MI, s, src, min, max)
  else {
    selectionResult(ch, MI, s) := undef
    receivers(ch, MI, s) := res

    SetExecutionState(MI, s, REPEAT)
  }
\end{minted}
\caption{SelectReceivers_Selection}
\label{lst:asm:SelectReceivers_Selection}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortSend(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    foreach r in reservationsDone(ch, MI, s) do {
      CancelReservation(MI, s, r)
    }

    SetAbortionCompleted(MI, s)
  }
\end{minted}
\caption{AbortSend}
\label{lst:asm:AbortSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionSend(MI, currentStateNumber, t) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in {
    let storeVName = messageStoreReceiverVar(pID, t) in
      if (storeVName != undef and storeVName != "") then
        SetVar(MI, storeVName, "ChannelInformation",
          reservationsDone(ch, MI, s))

    foreach r in reservationsDone(ch, MI, s) do {
      ReplaceReservation(MI, s, r)

      EnsureRunning(r)
    }

    SetCompletedTransition(MI, s, t)
  }
\end{minted}
\caption{PerformTransitionSend}
\label{lst:asm:PerformTransitionSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SetMessageContent(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
    if not(contains(wantInput(ch, MI, ch),
                    "MessageContentDecision")) then {
      add "MessageContentDecision" to wantInput(ch, MI, ch)
      SetExecutionState(MI, ch, DONE)
    }
    else
      // waiting for messageContent
      SetExecutionState(MI, ch, NEXT)
\end{minted}
\caption{SetMessageContent}
\label{lst:asm:SetMessageContent}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// handle all receivers
rule DoReservations(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
  local hasPlacedReservation := false in
    seq
      let receiversTodo = (receivers(ch, MI, s) diff
                           reservationsDone(ch, MI, s)) in
      foreach receiver in receiversTodo do
        local tmp := false in
          seq
            // result is true if a reservation was made
            tmp <- DoReservation(MI, s, receiver)
          next if (tmp = true) then
            hasPlacedReservation := true
    next
      if (hasPlacedReservation = true) then
        // reservation(s) placed, make update
        SetExecutionState(MI, s, DONE)
      else
        // no reservations made, allow other states
        SetExecutionState(MI, s, NEXT)
\end{minted}
\caption{DoReservations}
\label{lst:asm:DoReservations}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// handle single reservation
// result true if hasPlacedReservation, adds to reservationsDone
rule DoReservation(MI, currentStateNumber, receiverChannel) =
  if (properTerminated(receiverChannel) = true) then
    let pID = processIDFor(self) in
    // there must be exactly one transition
    let t                  = first_outgoingNormalTransition(pID, currentStateNumber),
        senderChannel      = channelFor(self),
        receiverProcessID  = processIDOf(receiverChannel) in
    let senderSubjectID    = searchSenderSubjectID(pID, subjectIDFor(self), receiverProcessID),
        msgCorrelationID   = loadCorrelationID(MI, messageNewCorrelationVar(pID, t)),
        ipCorrelationID    = loadCorrelationID(MI, messageWithCorrelationVar(pID, t)) in
    let reservationMessage = [senderChannel, messageType(pID, t), {}, msgCorrelationID, true] in
      seq
        // prepare receiver IP
        if (inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) = undef) then {
          add [senderSubjectID, messageType(pID, t), ipCorrelationID] to inputPoolDefined(receiverChannel)
          inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) := []
        }
      next
        if (inputPoolIsClosed(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) != true) then
          if (inputPoolGetFreeSpace(receiverChannel, senderSubjectID, messageType(pID, t)) > 0) then {
            enqueue reservationMessage into inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID)
            add receiverChannel to reservationsDone(channelFor(self), MI, currentStateNumber)
            result := true
          }
          else
            result := false // BLOCKED: no free space!
        else
          result := false // BLOCKED: inputPoolIsClosed
  else
    result := false // BLOCKED: non-properTerminated
\end{minted}
\caption{DoReservation}
\label{lst:asm:DoReservation}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CancelReservation(MI, currentStateNumber, receiverChannel) = {
  let pID          = processIDFor(self) in
  let transitionNumber   = first_outgoingNormalTransition(pID, currentStateNumber),
      senderChannel      = channelFor(self),
      receiverProcessID  = processIDOf(receiverChannel) in
  let senderSubjectID    = searchSenderSubjectID(pID, subjectIDFor(self), receiverProcessID),
      msgCorrelationID   = loadCorrelationID(MI, messageNewCorrelationVar(pID, transitionNumber)),
      ipCorrelationID    = loadCorrelationID(MI, messageWithCorrelationVar(pID, transitionNumber)) in
  let reservationMessage = [senderChannel, messageType(pID, transitionNumber), {}, msgCorrelationID, true],
      IP = inputPool(receiverChannel, senderSubjectID, messageType(pID, transitionNumber), ipCorrelationID) in {
      inputPool(receiverChannel, senderSubjectID, messageType(pID, transitionNumber), ipCorrelationID) := dropnth(IP, head(indexes(IP, reservationMessage)))
  }
}
\end{minted}
\caption{CancelReservation}
\label{lst:asm:CancelReservation}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ReplaceReservation(MI, currentStateNumber, receiverChannel) = {
  let pID          = processIDFor(self) in
  let transitionNumber   = first_outgoingNormalTransition(pID, currentStateNumber),
      senderChannel      = channelFor(self),
      receiverProcessID  = processIDOf(receiverChannel) in
  let senderSubjectID    = searchSenderSubjectID(pID, subjectIDFor(self), receiverProcessID),
      msgCorrelationID   = loadCorrelationID(MI, messageNewCorrelationVar(pID, transitionNumber)),
      ipCorrelationID    = loadCorrelationID(MI, messageWithCorrelationVar(pID, transitionNumber)) in
  let reservationMessage = [senderChannel, messageType(pID, transitionNumber), {}, msgCorrelationID, true],
      message            = [senderChannel, messageType(pID, transitionNumber), messageContent(channelFor(self), MI, currentStateNumber), msgCorrelationID, false],
      IP = inputPool(receiverChannel, senderSubjectID, messageType(pID, transitionNumber), ipCorrelationID) in {
      // TODO: discuss: setnth or dropnth & enqueue?
      inputPool(receiverChannel, senderSubjectID, messageType(pID, transitionNumber), ipCorrelationID) := setnth(IP, head(indexes(IP, reservationMessage)), message)
  }
}
\end{minted}
\caption{ReplaceReservation}
\label{lst:asm:ReplaceReservation}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformReceive(MI, currentStateNumber) = {
  // startTime must be the time of the first attempt to receive in order to support receiving with timeout=0
  if (startTime(channelFor(self), MI, currentStateNumber) = undef) then {
    StartTimeout(MI, currentStateNumber)

    SetExecutionState(MI, currentStateNumber, REPEAT)
  }
  else {
    if (shouldTimeout(channelFor(self), MI, currentStateNumber) = true) then {
      SetCompleted(MI, currentStateNumber) // sets executionState to REPEAT
      ActivateTimeout(MI, currentStateNumber)
    }
    else {
      let pID = processIDFor(self) in
      seq
        forall transitionNumber in outgoingNormalTransitions(pID, currentStateNumber) do {
          CheckIP(MI, currentStateNumber, transitionNumber)
        }
      next
        let enabledOutgoingTransitions = outgoingEnabledTransitions(channelFor(self), MI, currentStateNumber) in {
          if (|enabledOutgoingTransitions| > 0) then {
            seqblock
            debuginfo PerformReceive self + ": at least one IP with messages :)"

            if (selectedTransition(channelFor(self), MI, currentStateNumber) != undef) then {
              debuginfo PerformReceive self + ": skipping automatic decision, there is already an transition selected: " + selectedTransition(channelFor(self), MI, currentStateNumber)
            }
            else if (|enabledOutgoingTransitions| = 1) then {
              let transitionNumber = firstFromSet(enabledOutgoingTransitions) in {
                if (transitionIsAuto(pID, transitionNumber) = true) then {
                  debuginfo PerformReceive self + ": making automatic decision for transition " + transitionPretty(MI, transitionNumber)
                  selectedTransition(channelFor(self), MI, currentStateNumber) := transitionNumber
                }
                else {
                  debuginfo PerformReceive self + ": can not make automatic decision, not an auto transition: " + transitionPretty(MI, transitionNumber)
                }
              }
            }
            else {
              debuginfo PerformReceive self + ": can not make automatic decision, too much transitions: " + enabledOutgoingTransitions
            }

            if (selectedTransition(channelFor(self), MI, currentStateNumber) != undef) then {
              debuginfo PerformReceive self + ": the decision has been made.."
              SetCompleted(MI, currentStateNumber) // sets executionState to REPEAT
            }
            else {
              debuginfo PerformReceive self + ": no decision made, waiting for selectedTransition"

              SelectTransition(MI, currentStateNumber)
            }
            endseqblock
          }
          else {
            debuginfo PerformReceive self + ": no IP with messages, trying later.."
            SetExecutionState(MI, currentStateNumber, LOWER)
          }
        }
    }
  }
}
\end{minted}
\caption{PerformReceive}
\label{lst:asm:PerformReceive}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionReceive(MI, currentStateNumber, transitionNumber) = {
  ReceiveMessage(MI, currentStateNumber, transitionNumber)
}
\end{minted}
\caption{PerformTransitionReceive}
\label{lst:asm:PerformTransitionReceive}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ReceiveMessage(MI, currentStateNumber, transitionNumber) = {
  let pID   = processIDFor(self) in
  let s           = messageSubjectId         (pID, transitionNumber),
      sChsVName = messageSubjectVar        (pID, transitionNumber),
      mt          = messageType              (pID, transitionNumber),
      cIDVName  = messageWithCorrelationVar(pID, transitionNumber) in
  // TODO 2019-02-22: local receivedMessages ? Or is that function used elsewhere?
  // Alternative: directly return as listres via result in InputPool_Pop?
  local stringres1, // subjectID
      setres1,    // subjectChannels
      stringres2, // messageType
      numres1 in  // correlationID
  seqblock

      debuginfo ReceiveMessage self + ": ReceiveMessage in state " + statePretty(MI, currentStateNumber) + " with transition " + transitionPretty(MI, transitionNumber)

      // TODO/NOTE: same structure as CheckIP. May refactor to reduce duplicated code?

      if (s = "*") then {
        debuginfo ReceiveMessage self + ": wildcard for subject is ? and not *"
        Crash()
      }
      else if (s = "?") then {
        stringres1 := undef
      }
      else {
        stringres1 := s
      }


      if (sChsVName = undef or sChsVName = "") then {
        setres1 := undef
      }
      else {
        seq
          setres1 := loadChannelsFromVariable(MI, sChsVName, s) // (stringres1 would be fine too)
        next
          debuginfo CheckIP self + ": considering only messages from the following channels: " + setres1
      }


      if (mt = "*") then {
        debuginfo ReceiveMessage self + ": wildcard for message type is ? and not *"
        Crash()
      }
      else if (mt = "?") then {
        stringres2 := undef
      }
      else {
        stringres2 := mt
      }


      if (cIDVName = "*") then {
        debuginfo ReceiveMessage self + ": wildcard for cID type is ? and not *"
        Crash()
      }
      else if (cIDVName = "?") then {
        numres1 := undef
      }
      else {
        numres1 := loadCorrelationID(MI, cIDVName)
      }



      let sL    = stringres1,
        sChsL = setres1,
        mtL   = stringres2,
        cL    = numres1,
        countMinL = messageSubjectCountMin(pID, transitionNumber),
        countMaxL = messageSubjectCountMax(pID, transitionNumber) in {
        // InputPool_Pop stores the popped messages in receivedMessages
        // undef is wildcard
        InputPool_Pop(MI, currentStateNumber, sL, sChsL, mtL, cL, countMinL, countMaxL)
      }

      let msgs = receivedMessages(channelFor(self), MI, currentStateNumber) in {
        debuginfo ReceiveMessage self + ": receivedMessages: " + msgs

        if (messageStoreMessagesVar(pID, transitionNumber) != undef and messageStoreMessagesVar(pID, transitionNumber) != "") then {
          let varname = messageStoreMessagesVar(pID, transitionNumber) in {
              debuginfo ReceiveMessage self + ": storing messages in: '" + varname + "'"
              SetMessageSet(MI, varname, msgs)
          }
        }
      }

      SetCompletedTransition(MI, currentStateNumber, transitionNumber) // sets executionState to REPEAT
  endseqblock
}
\end{minted}
\caption{ReceiveMessage}
\label{lst:asm:ReceiveMessage}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CheckIP(MI, currentStateNumber, transitionNumber) = {
  let pID   = processIDFor(self) in
  let sID         = messageSubjectId         (pID, transitionNumber),
      sChsVName = messageSubjectVar        (pID, transitionNumber),
      mT          = messageType              (pID, transitionNumber),
      cIDVName  = messageWithCorrelationVar(pID, transitionNumber) in
  local stringres1, // subjectID
      setres1,    // subjectChannels
      stringres2, // messageType
      numres1 in  // correlationID
  seqblock

      // TODO/NOTE: same structure as ReceiveMessage. May refactor to reduce duplicated code?

      if (sID = "?") then {
        stringres1 := undef
      }
      else if (sID = "*") then {
        debuginfo CheckIP self + ": subject wildcard is '?'"
        Crash()
      }
      else {
        stringres1 := sID
      }


      if (sChsVName = undef or sChsVName = "") then {
        setres1 := undef
      }
      else {
        seq
          setres1 := loadChannelsFromVariable(MI, sChsVName, sID) // (stringres1 would be fine too)
        next
          debuginfo CheckIP self + ": considering only messages from the following channels: " + setres1
      }


      if (mT = "?") then {
        stringres2 := undef
      }
      else if (mT = "*") then {
        debuginfo CheckIP self + ": message type wildcard is '?'"
        Crash()
      }
      else {
        stringres2 := mT
      }


      if (cIDVName = "?") then {
        numres1 := undef
      }
      else if (cIDVName = "*") then {
        debuginfo CheckIP self + ": correlationID wildcard is '?'"
        Crash()
      }
      else {
        numres1 := loadCorrelationID(MI, messageWithCorrelationVar(pID, transitionNumber))
      }


      // no reservations, supress multiple channels
      let usedSpace = inputPoolUsedSpace(channelFor(self), stringres1, setres1, stringres2, numres1, true, true) in {
        if (messageSubjectCountMin(pID, transitionNumber) = 0) then {
          if (usedSpace > |setres1|) then {
              debuginfo CheckIP self + ": WARN: internal error: more messages than expected senders! " + usedSpace + " > " + |setres1|
              Crash()
          }
          else if (usedSpace = |setres1|) then {
              debuginfo CheckIP self + ": enough messages :) " + usedSpace + " = " + |setres1|
              EnableTransition(MI, transitionNumber)
          }
          else {
              debuginfo CheckIP self + ": Not enough messages: " + usedSpace + " < " + |setres1|
              DisableTransition(MI, currentStateNumber, transitionNumber)
          }
        }
        else if (usedSpace >= messageSubjectCountMin(pID, transitionNumber)) then {
          debuginfo CheckIP self + ": enough messages :) " + usedSpace + " >= " + messageSubjectCountMin(pID, transitionNumber)
          EnableTransition(MI, transitionNumber)
        }
        else {
          debuginfo CheckIP self + ": Not enough messages: " + usedSpace + " < " + messageSubjectCountMin(pID, transitionNumber)
          DisableTransition(MI, currentStateNumber, transitionNumber)
        }
      }
  endseqblock
}
\end{minted}
\caption{CheckIP}
\label{lst:asm:CheckIP}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartEnd(MI, currentStateNumber) = {
  SetExecutionState(MI, currentStateNumber, REPEAT)
}
\end{minted}
\caption{StartEnd}
\label{lst:asm:StartEnd}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformEnd(MI, currentStateNumber) = {
  if (|activeStates(channelFor(self), MI)| > 1) then {
      AbortMacroInstance(MI, currentStateNumber) // do not remove self. calls ClearAllVarInMIForChannel bat that's not needed

      SetExecutionState(MI, currentStateNumber, DONE)
  }
  else {
      if (MI = 1) then {
        let res = head(stateFunctionArguments(processIDFor(self), currentStateNumber)) in {
          // just for debugging purposes, a termination of the Main Macro should not have a result, but this is used in TestTransitions2
          if (res = undef) then { // no parameters for End state
              debuginfo PerformEnd self + ": within mainMacro, terminate subject without result value"
          }
          else {
              debuginfo PerformEnd self + ": within mainMacro. WARN: terminate subject with result value: " + res
          }
        }

        ClearAllVarInMIForChannel(channelFor(self), 0)
        ClearAllVarInMIForChannel(channelFor(self), 1)

        FinalizeInteraction()

        program(self) := undef
        remove self from asmAgents
      }
      else {
        ClearAllVarInMIForChannel(channelFor(self), MI)

        let res = head(stateFunctionArguments(processIDFor(self), currentStateNumber)) in {
          if (res = undef) then { // no parameters for End state
              debuginfo PerformEnd self + ": terminated without result value"
              macroTerminationResult(channelFor(self), MI) := true
          }
          else {
              debuginfo PerformEnd self + ": terminated with result value: " + res
              macroTerminationResult(channelFor(self), MI) := res
          }
        }
      }

      // remove self
      RemoveState(MI, currentStateNumber, MI, currentStateNumber)
      SetExecutionState(MI, currentStateNumber, DONE)
  }
}
\end{minted}
\caption{PerformEnd}
\label{lst:asm:PerformEnd}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartTau(MI, currentStateNumber) = {
  EnableAllTransitions(MI, currentStateNumber)
}

rule Tau(MI, currentStateNumber, args) = {
  let pID = processIDFor(self) in {
      choose transitionNumber in outgoingEnabledTransitions(channelFor(self), MI, currentStateNumber) with (transitionIsAuto(pID, transitionNumber) = true) do {
        debuginfo Tau self + ": transition chosen, it is normal and auto: " + transitionPretty(MI, transitionNumber)

        selectedTransition(channelFor(self), MI, currentStateNumber) := transitionNumber

        SetCompleted(MI, currentStateNumber) // sets executionState to REPEAT
      }
      ifnone {
        debuginfo Tau self + ": unable to choose auto transition!"

        if (selectedTransition(channelFor(self), MI, currentStateNumber) != undef) then {
          debuginfo Tau self + ": selectedTransition had been set"
          SetCompleted(MI, currentStateNumber) // sets executionState to REPEAT
        }
        else {
          debuginfo Tau self + ": SelectTransition"
          SelectTransition(MI, currentStateNumber)
        }
      }
  }
}
\end{minted}
\caption{Tau}
\label{lst:asm:Tau}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortVarMan(MI, currentStateNumber) = {
  ResetSelection(MI, currentStateNumber)
  SetAbortionCompleted(MI, currentStateNumber)
}

rule VarMan(MI, currentStateNumber, args) = {
  let method = head(args) in {
      debuginfo VarMan self + ": method: " + method
      debuginfo VarMan self + ": args: " + tail(args)

      case method of
        "assign"                : VarMan_Assign               (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "storeData"             : VarMan_StoreData            (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "clear"                 : VarMan_Clear                (MI, currentStateNumber, nth(args, 2))

        "concatenation"         : VarMan_Concatenation        (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4))
        "intersection"          : VarMan_Intersection         (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4))
        "difference"            : VarMan_Difference           (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4))

        "extractContent"        : VarMan_ExtractContent       (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "extractChannel"        : VarMan_ExtractChannel       (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "extractCorrelationID"  : VarMan_ExtractCorrelationID (MI, currentStateNumber, nth(args, 2), nth(args, 3))

        "selection"             : VarMan_Selection            (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4), nth(args, 5))
      endcase
  }
}


rule VarMan_Assign(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
      SetVar(MI, X, head(a), last(a))

      SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
  }
}

rule VarMan_StoreData(MI, currentStateNumber, X, A) = {
  SetVar(MI, X, "Data", A)

  SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
}

rule VarMan_Clear(MI, currentStateNumber, X) = {
  ClearVar(MI, X)

  SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
}

rule VarMan_Concatenation(MI, currentStateNumber, A, B, X) = {
  let a = loadVar(MI, A),
      b = loadVar(MI, B) in {
      if (a = undef and b = undef) then {
        ClearVar(MI, X)

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (a = undef) then {
        SetVar(MI, X, head(b), last(b))

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (b = undef) then {
        SetVar(MI, X, head(a), last(a))

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (head(a) != head(b) or not(contains({"MessageSet", "ChannelInformation"}, head(a)))) then {
        debuginfo VarMan_Concatenation self + ": invalid parameters"

        Crash()
      }
      else {
        let x = (last(a) union last(b)) in {
          SetVar(MI, X, head(a), x)

          SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
        }
      }
  }
}

rule VarMan_Intersection(MI, currentStateNumber, A, B, X) = {
  let a = loadVar(MI, A) in
  let b = loadVar(MI, B) in {
      if (a = undef or b = undef) then {
        ClearVar(MI, X)

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (head(a) != head(b) or not(contains({"MessageSet", "ChannelInformation"}, head(a)))) then {
        debuginfo VarMan_Intersection self + ": invalid parameters"
        debuginfo VarMan_Intersection self + ": A = " + undefStr(A)
        debuginfo VarMan_Intersection self + ": a = " + undefStr(a)
        debuginfo VarMan_Intersection self + ": B = " + undefStr(B)
        debuginfo VarMan_Intersection self + ": b = " + undefStr(b)

        Crash()
      }
      else {
        let x = (last(a) intersect last(b)) in {
          SetVar(MI, X, head(a), x)

          SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
        }
      }
  }
}

rule VarMan_Difference(MI, currentStateNumber, A, B, X) = {
  let a = loadVar(MI, A) in
  let b = loadVar(MI, B) in {
      if (a = undef) then {
        ClearVar(MI, X)

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (b = undef) then {
        SetVar(MI, X, head(a), last(a))

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (head(a) != head(b) or not(contains({"MessageSet", "ChannelInformation"}, head(a)))) then {
        debuginfo VarMan_Difference self + ": invalid parameters"
        debuginfo VarMan_Difference self + ": A = " + undefStr(A)
        debuginfo VarMan_Difference self + ": a = " + undefStr(a)
        debuginfo VarMan_Difference self + ": B = " + undefStr(B)
        debuginfo VarMan_Difference self + ": b = " + undefStr(b)

        Crash()
      }
      else {
        let x = (last(a) diff last(b)) in {
          SetVar(MI, X, head(a), x)

          SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
        }
      }
  }
}


rule VarMan_ExtractContent(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
    // TODO: How to deal with empty / undef variables?
    if (head(a) != "MessageSet") then {
      debuginfo VarMan_ExtractContent self + ": invalid parameter"
      debuginfo VarMan_ExtractContent self + ": A = " + undefStr(A)
      debuginfo VarMan_ExtractContent self + ": a = " + undefStr(a)

      Crash()
    }
    else {
      let messages = last(a) in
      let messagesContent = map(messages, @msgContent) in {
        if (| messagesContent | = 0) then {
          debuginfo VarMan_ExtractContent self + ": no content to extract"
          Crash()
        }
        else if (| messagesContent | = 1) then {
          let content = firstFromSet(messagesContent) in {
            debuginfo VarMan_ExtractContent self + ": exact one content to extract: " + content
            SetVar(MI, X, head(content), last(content))
          }
        }
        else {
          // check if all contents have the same type, and that the type is union-able
          let x = firstFromSet(messagesContent) in {
            if (head(x) = "MessageSet" or head(x) = "ChannelInformation") then {
              // check if all are the same type
              if (forall y in messagesContent holds (head(y) = head(x))) then {
                debuginfo VarMan_ExtractContent self + ": flattening content: " + content
                SetVar(MI, X, head(x), flattenSet(map(messagesContent, @last)))
              }
              else {
                debuginfo VarMan_ExtractContent self + ": all messages must have the same underlying datatype!"
                debuginfo VarMan_ExtractContent self + ": messages: " + messages
                debuginfo VarMan_ExtractContent self + ": messagesContent: " + messagesContent

                Crash()
              }
            }
            else {
              debuginfo VarMan_ExtractContent self + ": invalid message content type, can not be merged: '" + head(x) + "'"

              Crash()
            }
          }
        }

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
    }
  }
}

rule VarMan_ExtractChannel(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
    // TODO: How to deal with empty / undef variables?
    if (head(a) != "MessageSet") then {
      debuginfo VarMan_ExtractChannel self + ": invalid parameter"
      debuginfo VarMan_ExtractChannel self + ": A = " + undefStr(A)
      debuginfo VarMan_ExtractChannel self + ": a = " + undefStr(a)

      Crash()
    }
    else {
      let messages = last(a) in
      let messagesChannel = map(messages, @msgChannel) in {
        if (| messagesChannel | = 0) then {
          debuginfo VarMan_ExtractChannel self + ": no channels to extract"
          Crash()
        }
        else {
          debuginfo VarMan_ExtractChannel self + ": messagesChannel: " + messagesChannel
          SetVar(MI, X, "ChannelInformation", messagesChannel)
        }

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
    }
  }
}

rule VarMan_ExtractCorrelationID(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
    // TODO: How to deal with empty / undef variables?
    if (head(a) != "MessageSet") then {
      debuginfo VarMan_ExtractCorrelationID self + ": invalid parameter"
      debuginfo VarMan_ExtractCorrelationID self + ": A = " + undefStr(A)
      debuginfo VarMan_ExtractCorrelationID self + ": a = " + undefStr(a)

      Crash()
    }
    else {
      let messages = last(a) in
      let messagesCorrelationID = map(messages, @msgCorrelation) in {
        if (| messagesCorrelationID | != 1) then {
          debuginfo VarMan_ExtractCorrelationID self + ": a CorrelationID can only be extracted when there is exactly one, got: " + messagesCorrelationID
          Crash()
        }
        else {
          debuginfo VarMan_ExtractCorrelationID self + ": messagesCorrelationID: " + messagesCorrelationID
          SetVar(MI, X, "CorrelationID", firstFromSet(messagesCorrelationID))
        }

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
    }
  }
}
\end{minted}
\caption{VarMan}
\label{lst:asm:VarMan}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// CH * MI * n
function selectionVartype  : LIST * NUMBER * NUMBER -> STRING
function selectionData     : LIST * NUMBER * NUMBER -> LIST
function selectionOptions  : LIST * NUMBER * NUMBER -> LIST
function selectionMin      : LIST * NUMBER * NUMBER -> NUMBER
function selectionMax      : LIST * NUMBER * NUMBER -> NUMBER
function selectionDecision : LIST * NUMBER * NUMBER -> SET

function selectionResult   : LIST * NUMBER * NUMBER -> SET

rule VarMan_Selection(MI, currentStateNumber, srcVName, dstVName, minimum, maximum) = {
  let src = loadVar(MI, srcVName),
    res = selectionResult(channelFor(self), MI, currentStateNumber) in
  if (res = undef) then {
    // TODO: cancel / timeout transition?
    Selection(MI, currentStateNumber, src, minimum, maximum)
  }
  else {
    selectionResult(channelFor(self), MI, currentStateNumber) := undef

    SetVar(MI, dstVName, head(src), res)

    SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
  }
}

rule ResetSelection(MI, currentStateNumber) = {
  selectionVartype (channelFor(self), MI, currentStateNumber) := undef
  selectionData    (channelFor(self), MI, currentStateNumber) := undef
  selectionOptions (channelFor(self), MI, currentStateNumber) := undef
  selectionMin     (channelFor(self), MI, currentStateNumber) := undef
  selectionMax     (channelFor(self), MI, currentStateNumber) := undef
  selectionDecision(channelFor(self), MI, currentStateNumber) := undef
}

rule Selection(MI, currentStateNumber, src, minimum, maximum) = {
  if (selectionData(channelFor(self), MI, currentStateNumber) = undef) then {
      if (head(src) = "MessageSet") then {
        let l = toList(last(src)) in {
          selectionData   (channelFor(self), MI, currentStateNumber) := l
          selectionOptions(channelFor(self), MI, currentStateNumber) := map(l, @msgToString)
        }
      }
      else if (head(src) = "ChannelInformation") then {
        let l = toList(last(src)) in {
          selectionData   (channelFor(self), MI, currentStateNumber) := l
          selectionOptions(channelFor(self), MI, currentStateNumber) := map(l, @chToString)
        }
      }
      else {
        debuginfo Selection self + ": can not perform selection on datatype '" + head(x) + "'"

        Crash()
      }

      selectionVartype (channelFor(self), MI, currentStateNumber) := head(src)
      selectionMin     (channelFor(self), MI, currentStateNumber) := minimum
      selectionMax     (channelFor(self), MI, currentStateNumber) := maximum
      selectionDecision(channelFor(self), MI, currentStateNumber) := undef // just to be sure

      SetExecutionState(MI, currentStateNumber, REPEAT)
  }
  else if (selectionDecision(channelFor(self), MI, currentStateNumber) = undef) then {
      if not(contains(wantInput(channelFor(self), MI, currentStateNumber), "SelectionDecision")) then {
        add "SelectionDecision" to wantInput(channelFor(self), MI, currentStateNumber)

        SetExecutionState(MI, currentStateNumber, DONE)
      }
      else {
        debuginfo Selection self + ": waiting for selectionDecision"
        SetExecutionState(MI, currentStateNumber, NEXT)
      }
  }
  else {
      let res = pickItems(selectionData(channelFor(self), MI, currentStateNumber), selectionDecision(channelFor(self), MI, currentStateNumber)) in {
        selectionResult(channelFor(self), MI, currentStateNumber) := res
      }

      ResetSelection(MI, currentStateNumber)

      SetExecutionState(MI, currentStateNumber, REPEAT)
  }
}
\end{minted}
\caption{VarMan_Selection}
\label{lst:asm:VarMan_Selection}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ModalSplit(MI, currentStateNumber, args) = {
  seqblock
    // start each following state
    foreach transitionNumber in outgoingNormalTransitions(processIDFor(self), currentStateNumber) do {
      let sNew = targetStateNumber(processIDFor(self), transitionNumber) in {
        AddState(MI, currentStateNumber, MI, sNew)
      }
    }

    // remove self
    RemoveState(MI, currentStateNumber, MI, currentStateNumber)

    SetExecutionState(MI, currentStateNumber, DONE)
  endseqblock
}
\end{minted}
\caption{ModalSplit}
\label{lst:asm:ModalSplit}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * joinState -> Number
function joinCount : LIST * NUMBER * NUMBER -> NUMBER

rule ModalJoin(MI, currentStateNumber, args) = {
  let splitCount = nth(args, 1) in
  seqblock
    debuginfo ModalJoin self + ": state: " + statePretty(MI, currentStateNumber)
    debuginfo ModalJoin self + ": splitCount: " + splitCount

    if (joinCount(channelFor(self), MI, currentStateNumber) = undef) then {
      joinCount(channelFor(self), MI, currentStateNumber) := 1
    }
    else {
      joinCount(channelFor(self), MI, currentStateNumber) := joinCount(channelFor(self), MI, currentStateNumber) + 1
    }

    debuginfo ModalJoin self + ": joinCount_post: " + joinCount(channelFor(self), MI, currentStateNumber)

    // can we continue, or remove self and wait for next path joining?
    if (joinCount(channelFor(self), MI, currentStateNumber) < splitCount) then {
      // remove self
      RemoveState(MI, currentStateNumber, MI, currentStateNumber)

      SetExecutionState(MI, currentStateNumber, DONE)
    }
    else {
      joinCount(channelFor(self), MI, currentStateNumber) := undef
      SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
    }
  endseqblock
}
\end{minted}
\caption{ModalJoin}
\label{lst:asm:ModalJoin}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortCallMacro(MI, currentStateNumber) = {
  let childInstance = callMacroChildInstance(channelFor(self), MI, currentStateNumber) in {
    if (|activeStates(channelFor(self), childInstance)| > 0) then {
      AbortMacroInstance(childInstance, undef)

      SetExecutionState(MI, currentStateNumber, DONE)
    }
    else {
      callMacroChildInstance(channelFor(self), MI, currentStateNumber) := undef

      SetAbortionCompleted(MI, currentStateNumber)  // sets executionState to DONE
    }
  }
}
\end{minted}
\caption{AbortCallMacro}
\label{lst:asm:AbortCallMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule InitializeMacroArguments(MI, currentStateNumber, mIDNew, MINew, macroArgumentsValues) = {
  local
    listres1 := macroArguments(processIDFor(self), mIDNew),
    listres2 := macroArgumentsValues in
  {
    if (|listres1| != |listres2|) then {
      debuginfo CallMacro self + ": Macro '"+macroID(processIDFor(self), mIDNew)+"' takes " + |listres1| + " arguments, but " + |listres2| + " given: " + listres2
      Crash()
    }

    while (|listres1| > 0) do {
      let varnameDst = head(listres1),
        varnameSrc = head(listres2) in
      let var = loadVar(MI, varnameSrc) in
      {
        if (var = undef) then {
          debuginfo CallMacro self + ": skipped local variable '" + varnameDst + "' from '" + varnameSrc + "' as its undef"
        }
        else {
          debuginfo CallMacro self + ": load local variable '" + varnameDst + "' from '" + varnameSrc + "': '" + var + "'"
          SetVar(MINew, varnameDst, nth(var, 1), nth(var, 2))
        }
      }

      listres1 := tail(listres1)
      listres2 := tail(listres2)
    }
  }
}
\end{minted}
\caption{InitializeMacroArguments}
\label{lst:asm:InitializeMacroArguments}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CallMacro(MI, currentStateNumber, args) = {
  let childInstance = callMacroChildInstance(channelFor(self), MI, currentStateNumber) in {
    // if Macro is not yet running..
    if (childInstance = undef) then {
      // TODO: consider to move this to a new rule StartCallMacro
      let mIDNew = searchMacro(head(args)),
        MINew  = nextMacroInstanceNumber(channelFor(self)) in seqblock
        nextMacroInstanceNumber(channelFor(self)) := MINew + 1
        macroNumberOfMI(channelFor(self), MINew) := mIDNew
        callMacroChildInstance(channelFor(self), MI, currentStateNumber) := MINew

        // NOTE: macroTerminationResult doesn't need to be initialized
        // as the MI part will be different in each iteration

        // if the Macro has parameters..
        if (|macroArguments(processIDFor(self), mIDNew)| > 0) then
        {
          InitializeMacroArguments(MI, currentStateNumber, mIDNew, MINew, tail(args))
        }

        SetExecutionState(MI, currentStateNumber, DONE)

        StartMacro(MI, currentStateNumber, mIDNew, MINew)
      endseqblock
    }
    else {
      debuginfo CallMacro self + ": childInstance: " + childInstance
      let childResult = macroTerminationResult(channelFor(self), childInstance) in {
        if (childResult != undef) then {
          debuginfo CallMacro self + ": childResult: " + childResult

          callMacroChildInstance(channelFor(self), MI, currentStateNumber) := undef

          if (childResult = true) then { // completed without result
            SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
          }
          else {
            SetCompletedAction(MI, currentStateNumber, childResult) // sets executionState to REPEAT
          }
        }
        else seqblock
          MacroBehavior(childInstance)

          let mState = macroExecutionState(channelFor(self), childInstance) in
            SetExecutionState(MI, currentStateNumber, mState)

          // reset
          macroExecutionState(channelFor(self), childInstance) := undef
        endseqblock
      }
    }
  }
}
\end{minted}
\caption{CallMacro}
\label{lst:asm:CallMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CheckCancel(MI, currentStateNumber, transitionNumber) = {
  let pID = processIDFor(self) in
  let tName = transitionLabel(pID, transitionNumber) in
  let nCancel = stateNumberFromID(pID, tName) in {
    if (contains(activeStates(channelFor(self), MI), nCancel) = true) then {
      debuginfo CheckCancel self + ": at least one state active!" // at least? if nothing went wrong it should be at most one as cancel on modal join makes no sense..
      EnableTransition(MI, transitionNumber)
    }
    else {
      debuginfo CheckCancel self + ": currently no state active!"
      DisableTransition(MI, currentStateNumber, transitionNumber)
    }
  }
}
\end{minted}
\caption{CheckCancel}
\label{lst:asm:CheckCancel}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Cancel(MI, currentStateNumber, args) = {
  let pID = processIDFor(self) in
  seqblock
    forall transitionNumber in outgoingNormalTransitions(pID, currentStateNumber) do {
      CheckCancel(MI, currentStateNumber, transitionNumber)
    }

    let enabledOutgoingTransitions = outgoingEnabledTransitions(channelFor(self), MI, currentStateNumber) in {
      if (|enabledOutgoingTransitions| > 0) then {
        seqblock
        debuginfo Cancel self + ": at least one transition with active states :)"

        if (|enabledOutgoingTransitions| = 1) then {
          let transitionNumber = firstFromSet(enabledOutgoingTransitions) in {
            if (transitionIsAuto(pID, transitionNumber) = true) then {
              debuginfo Cancel self + ": making automatic decision for transition " + transitionPretty(MI, transitionNumber)
              selectedTransition(channelFor(self), MI, currentStateNumber) := transitionNumber
            }
            else {
              debuginfo Cancel self + ": can not make automatic decision, not an auto transition: " + transitionPretty(MI, transitionNumber)
            }
          }
        }
        else {
          debuginfo Cancel self + ": can not make automatic decision, too much transitions: " + enabledOutgoingTransitions
        }

        if (selectedTransition(channelFor(self), MI, currentStateNumber) != undef) then {
          debuginfo Cancel self + ": the decision has been made for: " + transitionPretty(MI, selectedTransition(channelFor(self), MI, currentStateNumber))

          SetCompletedAction(MI, currentStateNumber, transitionLabel(pID, selectedTransition(channelFor(self), MI, currentStateNumber))) // sets executionState to REPEAT
        }
        else {
          SelectTransition(MI, currentStateNumber)
        }
        endseqblock
      }
      else {
        debuginfo Cancel self + ": no transition with active states, trying later.."
        SetExecutionState(MI, currentStateNumber, LOWER)
      }
    }
  endseqblock
}
\end{minted}
\caption{Cancel}
\label{lst:asm:Cancel}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionCancel(MI, currentStateNumber, transitionNumber) = {
  let pID = processIDFor(self) in {
    let tLabel = transitionLabel(pID, transitionNumber) in
    let nCancel = stateNumberFromID(pID, tLabel) in {
      cancelDecision(channelFor(self), MI, nCancel) := true

      SetCompletedTransition(MI, currentStateNumber, transitionNumber) // sets executionState to REPEAT
    }
  }
}
\end{minted}
\caption{PerformTransitionCancel}
\label{lst:asm:PerformTransitionCancel}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// no wildcards allowed
rule CloseIP(MI, currentStateNumber, args) = {
  let senderSubjID         = nth(args, 1),
      messageType          = nth(args, 2),
      correlationIDVName = nth(args, 3) in {
      if (messageType = "*" or messageType = "?" or senderSubjID = "*" or senderSubjID = "?" or correlationIDVName = "*" or correlationIDVName = "?") then {
        debuginfo CloseIP self + ": no wildcards allowed. You may want to use CloseAllIPs"
        Crash()
      }
      else {
        let correlationID = loadCorrelationID(MI, correlationIDVName) in {
          inputPoolClosed(channelFor(self), senderSubjID, messageType, correlationID) := true
          if (inputPool(channelFor(self), senderSubjID, messageType, correlationID) = undef) then {
              add [senderSubjID, messageType, correlationID] to inputPoolDefined(channelFor(self))
              inputPool(channelFor(self), senderSubjID, messageType, correlationID) := []
          }
        }
      }

      SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
  }
}
\end{minted}
\caption{CloseIP}
\label{lst:asm:CloseIP}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// no wildcards allowed
rule OpenIP(MI, currentStateNumber, args) = {
  let senderSubjID         = nth(args, 1),
      messageType          = nth(args, 2),
      correlationIDVName = nth(args, 3) in {
      if (messageType = "*" or messageType = "?" or senderSubjID = "*" or senderSubjID = "?" or correlationIDVName = "*" or correlationIDVName = "?") then {
        debuginfo OpenIP self + ": no wildcards allowed. You may want to use CloseAllIPs"
        Crash()
      }
      else {
        let correlationID = loadCorrelationID(MI, correlationIDVName) in {
          inputPoolClosed(channelFor(self), senderSubjID, messageType, correlationID) := false
          if (inputPool(channelFor(self), senderSubjID, messageType, correlationID) = undef) then {
              add [senderSubjID, messageType, correlationID] to inputPoolDefined(channelFor(self))
              inputPool(channelFor(self), senderSubjID, messageType, correlationID) := []
          }
        }
      }

      SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
  }
}
\end{minted}
\caption{OpenIP}
\label{lst:asm:OpenIP}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CloseAllIPs(MI, currentStateNumber, args) = {
  inputPoolClosed(channelFor(self), undef, undef, undef) := true

  forall key in inputPoolDefined(channelFor(self)) do {
      let sID = nth(key, 1),
        mT  = nth(key, 2),
        cID = nth(key, 3) in {
        inputPoolClosed(channelFor(self), sID, mT, cID) := true
      }
  }

  SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
}
\end{minted}
\caption{CloseAllIPs}
\label{lst:asm:CloseAllIPs}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule OpenAllIPs(MI, currentStateNumber, args) = {
  inputPoolClosed(channelFor(self), undef, undef, undef) := false

  forall key in inputPoolDefined(channelFor(self)) do {
      let sID = nth(key, 1),
        mT  = nth(key, 2),
        cID = nth(key, 3) in {
        inputPoolClosed(channelFor(self), sID, mT, cID) := false
      }
  }

  SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
}
\end{minted}
\caption{OpenAllIPs}
\label{lst:asm:OpenAllIPs}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// only correlation can be wildcard (*)
rule IsIPEmpty(MI, currentStateNumber, args) = {
  debuginfo IsIPEmpty self + ": args: " + args

  local numres in
  let senderSubjID         = nth(args, 1),
      messageType          = nth(args, 2),
      correlationIDVName = nth(args, 3) in
  seqblock

      if (correlationIDVName = undef or correlationIDVName = 0 or correlationIDVName = "") then {
        numres := 0
      }
      else if (correlationIDVName = "*") then {
        numres := undef
      }
      else if (correlationIDVName = "?") then {
        debuginfo OpenIP self + ": correlationIDVName must not be '?'. wildcard is '*'"
        Crash()
      }
      else {
        numres := loadCorrelationID(MI, correlationIDVName)
      }

      // receiverChannel * senderSubjID * messageType * correlationID
      if (inputPoolIsEmpty(channelFor(self), senderSubjID, messageType, numres) = true) then {
        SetCompletedAction(MI, currentStateNumber, "true") // sets executionState to REPEAT
      }
      else {
        SetCompletedAction(MI, currentStateNumber, "false") // sets executionState to REPEAT
      }
  endseqblock
}
\end{minted}
\caption{IsIPEmpty}
\label{lst:asm:IsIPEmpty}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function selectAgentsDecision : LIST * NUMBER * NUMBER -> SET

function selectAgentsProcessID : LIST * NUMBER * NUMBER -> STRING
function selectAgentsSubjectID : LIST * NUMBER * NUMBER -> STRING
function selectAgentsCountMin  : LIST * NUMBER * NUMBER -> NUMBER
function selectAgentsCountMax  : LIST * NUMBER * NUMBER -> NUMBER

function selectAgentsResult : LIST * NUMBER * NUMBER -> SET

rule SelectAgentsAction(MI, currentStateNumber, args) = {
  let
    varname  = nth(args, 1),
    sIDLocal = nth(args, 2),
    countMin = nth(args, 3),
    countMax = nth(args, 4) in
  {
    if (selectAgentsResult(channelFor(self), MI, currentStateNumber) != undef) then {
      SetVar(MI, varname, "ChannelInformation", selectAgentsResult(channelFor(self), MI, currentStateNumber))
      selectAgentsResult(channelFor(self), MI, currentStateNumber) := undef

      SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
    }
    else {
      SelectAgents(MI, currentStateNumber, sIDLocal, countMin, countMax)
    }
  }
}
\end{minted}
\caption{SelectAgentsAction}
\label{lst:asm:SelectAgentsAction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectAgents(MI, currentStateNumber, sIDLocal, countMin, countMax) = {
  if (sIDLocal = undef or sIDLocal = "?") then {
    debuginfo SelectAgents self + ": sIDLocal must not be wildcard/undef"
    Crash()
  }

  let pID = processIDFor(self),
      PI        = processInstanceFor(self) in
  let resolvedInterface = resolveInterfaceSubject(sIDLocal) in
  let resolvedProcessID = nth(resolvedInterface, 1),
      resolvedSubjectID = nth(resolvedInterface, 2) in
  if (selectAgentsDecision(channelFor(self), MI, currentStateNumber) != undef) then {
      // validate min/max
      if (hasSizeWithin(selectAgentsDecision(channelFor(self), MI, currentStateNumber), countMin, countMax) != true) then {
        debuginfo SelectAgents self + ": selectAgentsDecision is not within countMin/countMax: " + countMin + " <= " + |selectAgentsDecision(channelFor(self), MI, currentStateNumber)| + " <= " + countMax
        Crash()
      }

      local setres1 := {} in // created channels
        seq
          foreach agent in selectAgentsDecision(channelFor(self), MI, currentStateNumber) do { // note: forall not possible as nextPI is incremented
              if (resolvedProcessID = pID) then {
                // local process, use own PI
                let ch = [pID, PI, sIDLocal, agent] in {
                  InitializeSubject(ch)

                  add ch to setres1
                }
              }
              else {
                // external process, create new PI
                local numres1 in {
                  seq
                      numres1 <- StartProcess(resolvedProcessID, resolvedSubjectID, agent)
                  next {
                      let ch = [resolvedProcessID, numres1, resolvedSubjectID, agent] in
                        add ch to setres1
                  }
                }
              }
          }
        next
          selectAgentsResult(channelFor(self), MI, currentStateNumber) := setres1

      selectAgentsDecision (channelFor(self), MI, currentStateNumber) := undef

      selectAgentsCountMin (channelFor(self), MI, currentStateNumber) := undef
      selectAgentsCountMax (channelFor(self), MI, currentStateNumber) := undef
      selectAgentsProcessID(channelFor(self), MI, currentStateNumber) := undef
      selectAgentsSubjectID(channelFor(self), MI, currentStateNumber) := undef

      SetExecutionState(MI, currentStateNumber, REPEAT)
  }
  else if(hasSizeWithin(predefinedAgents(pID, PI, sIDLocal), countMin, countMax) = true) then {
      debuginfo SelectAgents self + ": apply predefinedAgents: " + predefinedAgents(pID, PI, sIDLocal)

      selectAgentsDecision(channelFor(self), MI, currentStateNumber) := predefinedAgents(pID, PI, sIDLocal)

      SetExecutionState(MI, currentStateNumber, REPEAT)
  }
  else {
      if not(contains(wantInput(channelFor(self), MI, currentStateNumber), "SelectAgentsDecision")) then {
        add "SelectAgentsDecision" to wantInput(channelFor(self), MI, currentStateNumber)

        selectAgentsProcessID(channelFor(self), MI, currentStateNumber) := resolvedProcessID
        selectAgentsSubjectID(channelFor(self), MI, currentStateNumber) := resolvedSubjectID
        selectAgentsCountMin (channelFor(self), MI, currentStateNumber) := countMin
        selectAgentsCountMax (channelFor(self), MI, currentStateNumber) := countMax

        selectAgentsResult(channelFor(self), MI, currentStateNumber) := undef

        SetExecutionState(MI, currentStateNumber, DONE)
      }
      else {
        debuginfo SelectAgents self + ": waiting for selectAgentsDecision"
        SetExecutionState(MI, currentStateNumber, NEXT)
      }
  }
}
\end{minted}
\caption{SelectAgents}
\label{lst:asm:SelectAgents}
\end{listing}
