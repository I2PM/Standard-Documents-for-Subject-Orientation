
%appendix in smaller font size
\footnotesize

\section{Conceptual Differences ASM Semantic / OWL Model}

% Some content might move to Appendix B / replace it.

This implementation provides more language elements than covered by the OWL description and also gives some concrete implementations.

Additionally to OWL:
\begin{itemize}
    \item Internal Behavior: usage of Subject Data: DataModificationFunction (VarMan: Selection, Concatenation, \ldots), DataMappingFunction (StoreMessage, UseMessageContent, UseCorrelationID).
    Subject Data can be scoped to Macro Instance.
    \item Interaction: Subject Restart, Inputpool Functions (CloseIP, OpenIP, \ldots), CorrelationID, Mobility of Channel.
\end{itemize}

There are also some conceptional differences and limitations:
\begin{itemize}
    \item only blocking asynchronous send, i.e. IP strategy blocking - no delete / drop. no sync send.
    \item modal split / join instead of ChoiceSegement. only mandatory to start and end / no optional start or optional end.
    \item timeout transitions: designed for interactive validation -> duration in seconds, no business days. also no reminders.
    \item Observer: different approach: no native support; possible via Modal Split + Receive State with State Priority + following Cancel Function
\end{itemize}



\newpage
\section{Actual Appendix}

\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
function channelFor : Agents -> LIST

derived processIDFor(a)       = processIDOf(channelFor(a))
derived processInstanceFor(a) = processInstanceOf(channelFor(a))
derived subjectIDFor(a)       = subjectIDOf(channelFor(a))
derived agentFor(a)           = agentOf(channelFor(a))

derived processIDOf(ch)       = nth(ch, 1)
derived processInstanceOf(ch) = nth(ch, 2)
derived subjectIDOf(ch)       = nth(ch, 3)
derived agentOf(ch)           = nth(ch, 4)
\end{minted}
\caption{channelFor}
\label{lst:asm:channelFor}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel -> List[List[MI, StateNumber]]
function killStates : LIST -> LIST

// Channel * macroInstanceNumber -> List[StateNumber]
function activeStates : LIST * NUMBER -> LIST
\end{minted}
\caption{activeStates}
\label{lst:asm:activeStates}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function initializedState : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function completed : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber
function timeoutActive  : LIST * NUMBER * NUMBER -> BOOLEAN
function cancelDecision : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function abortionCompleted : LIST * NUMBER * NUMBER -> BOOLEAN

// Channel * MacroInstanceNumber * StateNumber -> ..
function selectedTransition : LIST * NUMBER * NUMBER -> NUMBER // -> TransitionNumber
function initializedSelectedTransition : LIST * NUMBER * NUMBER -> BOOLEAN
function startTime  : LIST * NUMBER * NUMBER -> NUMBER

// can exit
// Channel * MacroInstanceNumber * TransitionNumber -> BOOLEAN
function exitCondition : LIST * NUMBER * NUMBER -> BOOLEAN
// TODO: may rename, possibly transitionEnabled ???

// Channel * MacroInstanceNumber * TransitionNumber -> BOOLEAN
function transitionCompleted : LIST * NUMBER * NUMBER -> BOOLEAN
\end{minted}
\caption{initializedState}
\label{lst:asm:initializedState}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
derived shouldTimeout(ch, MI, stateNumber) = return boolres in {
  let pID = processIDOf(ch) in {
    if (hasTimeoutTransition(pID, stateNumber) = true and startTime(ch, MI, stateNumber) != undef) then {
      let transitionNumber = outgoingTimeoutTransition(pID, stateNumber) in
      let timeout = transitionTimeout(pID, transitionNumber) * 1000 * 1000 * 1000 in {
        let runningTime = (nanoTime() - startTime(ch, MI, stateNumber)) in
          boolres := (runningTime > timeout)
      }
    }
    else {
      boolres := false
    }
  }
}
\end{minted}
\caption{shouldTimeout}
\label{lst:asm:shouldTimeout}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * macroInstanceNumber * varname -> [vartype, content]
function variable : LIST * NUMBER * STRING -> LIST

// Channel -> Set[(macroInstanceNumber, varname)]
function variableDefined : LIST -> SET
\end{minted}
\caption{variable}
\label{lst:asm:variable}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// receiverChannel * senderSubjID * messageType * correlationID -> [msg1, msg2, ...]
function inputPool : LIST * STRING * STRING * NUMBER -> LIST

/* store all locations where an inputPool was defined for to allow IPEmpty and receiving from "?" */
// receiverChannel -> {[senderSubjID, messageType, correlationID], ..}
function inputPoolDefined : LIST -> SET
\end{minted}
\caption{inputPool}
\label{lst:asm:inputPool}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * StateNumber -> Set[Messages]
function receivedMessages : LIST * NUMBER * NUMBER -> SET

// Channel * MacroInstanceNumber * StateNumber -> Set[Channel]
function receivers : LIST * NUMBER * NUMBER -> SET

// Channel * MacroInstanceNumber * StateNumber -> STRING
function messageContent : LIST * NUMBER * NUMBER -> LIST

// Channel * MacroInstanceNumber * StateNumber -> Set[Channel]
function reservationsDone : LIST * NUMBER * NUMBER -> SET
\end{minted}
\caption{receivedMessages}
\label{lst:asm:receivedMessages}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * macroInstanceNumber -> result
function macroTerminationResult : LIST * NUMBER -> ELEMENT

// Channel * macroInstanceNumber -> MacroNumber
function macroNumberOfMI : LIST * NUMBER -> NUMBER

// Channel * macroInstanceNumber * StateNumber -> MacroInstance
function callMacroChildInstance : LIST * NUMBER * NUMBER -> NUMBER
\end{minted}
\caption{macroTerminationResult}
\label{lst:asm:macroTerminationResult}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// called form PerformEnd and AbortCallMacro
rule AbortMacroInstance(MIAbort, ignoreState) =
  let ch = channelFor(self) in {
    foreach currentState in activeStates(ch, MIAbort) do {
      add [MIAbort, currentState] to killStates(ch)
    }

    ClearAllVarInMI(ch, MIAbort)
  }
\end{minted}
\caption{AbortMacroInstance}
\label{lst:asm:AbortMacroInstance}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// -> SET[ASMAgent]
function asmAgents : -> SET

derived running(ch) = exists a in asmAgents
                        with channelFor(a) = ch

rule EnsureRunning(ch) =
  if (running(ch) != true) then
    StartASMAgent(ch)

rule StartASMAgent(ch) =
  extend Agents with a do {
    add a to asmAgents
    channelFor(a) := ch
    program(a)    := @StartMainMacro
  }
\end{minted}
\caption{StartASMAgent}
\label{lst:asm:StartASMAgent}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small,escapeinside=~~]{lexer.py:CoreASMLexer -x}
rule StartMainMacro =
  let ch = channelFor(self),
     pID = processIDFor(self) in {
    killStates(ch) := []

    let MI = 0 in { // 0 => global / predefined variables
      variableDefined(ch) := {[MI, "$self"], [MI, "$empty"]}
      variable(ch, MI, "$self") := ["ChannelInformation", {ch}]
      variable(ch, MI, "$empty") := ["Text", ""]
    }

    let MI  = 1, // 1 => MainMacro Instance
        mID = subjectMainMacro(pID, subjectIDFor(self)) in
    let startState = macroStartState(pID, mID) in {
      macroNumberOfMI(ch, MI) := mID

      nextMacroInstanceNumber(ch) := MI  + 1

      activeStates(ch, MI) := [startState]
    }

    program(self) := @SubjectBehavior
  }
\end{minted}
\caption{StartMainMacro}
\label{lst:asm:StartMainMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartMacro(MI, currentStateNumber, mIDNew, MINew) = {
  let pID = processIDFor(self) in
  let startState = macroStartState(pID, mIDNew) in {
    activeStates(channelFor(self), MINew) := []
    AddState(MI, currentStateNumber, MINew, startState)
  }
}
\end{minted}
\caption{StartMacro}
\label{lst:asm:StartMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
/*
0 - REPEAT
  -* Behavior should be executed again for this state
  -* results of previous execution will be merged with following execution in one global ASM step
  -* no other states are allowed to be executed
1 - DONE
  -* no other active states are allowed to be executed
  -* new states are started
  -* global ASM / LTS step should be done
2 - NEXT
  -* nothing changed / waiting for input
  -* other active states with the same priority can be executed
  -* active states with lower priority can not be executed
3 - LOWER
  -* nothing changed / waiting for input
  -* other active states, even with lower priority, can be executed
*/

// ch * MacroInstanceNumber * stateNumber => Int
function executionState : LIST * NUMBER * NUMBER -> NUMBER


/*
1 - DONE
2 - NEXT
3 - LOWER
*/
// ch * MacroInstanceNumber => Int
function macroExecutionState : LIST * NUMBER -> NUMBER

// ch * MacroInstanceNumber * stateNumber => List[(MI, s)]
function addStates : LIST * NUMBER * NUMBER -> LIST

// ch * MacroInstanceNumber * stateNumber => List[(MI, s)]
function removeStates : LIST * NUMBER * NUMBER -> LIST
\end{minted}
\caption{SetExecutionState}
\label{lst:asm:SetExecutionState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AddState(MI, currentStateNumber, MINew, sNew) = {
  add [MINew, sNew] to addStates(channelFor(self), MI, currentStateNumber)
}

rule RemoveState(MI, currentStateNumber, MIOld, sOld) = {
  add [MIOld, sOld] to removeStates(channelFor(self), MI, currentStateNumber)
}
\end{minted}
\caption{AddState}
\label{lst:asm:AddState}
\end{listing}







\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SubjectBehavior = {
  choose x in killStates(channelFor(self)) do {
    KillBehavior(nth(x, 1), nth(x, 2))
  }
  ifnone seqblock
    MacroBehavior(1)

    // reset
    macroExecutionState(channelFor(self), 1) := undef
  endseqblock
}
\end{minted}
\caption{SubjectBehavior}
\label{lst:asm:SubjectBehavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule KillBehavior(MI, currentStateNumber) =
 let s = currentStateNumber,
    ch = channelFor(self) in
  if (initializedState(ch, MI, s) != true) then {
    remove [MI, s] from killStates(ch)
    remove n from activeStates(ch, MI)
  }
  else seqblock
    executionState(ch, MI, s) := undef
    addStates(ch, MI, s)       := []
    removeStates(ch, MI, s)    := []

    if (abortionCompleted(ch, MI, s) != true) then
      Abort(MI, s)
    else {
      RemoveState(MI, s, MI, s)
      SetExecutionState(MI, s, DONE)
    }

    if (executionState(ch, MI, s) != 1) then {
      Crash()
    }
    else if (|addStates(ch, MI, s)| > 0) then {
      Crash()
    }
    else if (|removeStates(ch, MI, s)| > 0) then {
      if (removeStates(ch, MI, s) != [[MI, s]]) then {
        Crash()
      }
      else {
        foreach x in removeStates(ch, MI, s) do {
          let xMI = nth(x, 1),
            xN  = nth(x, 2) in {
            remove [xMI, xN] from killStates(ch)
            ResetState(xMI, xN)
            remove xN from activeStates(ch, xMI)
          }
        }
      }
    }
  endseqblock
\end{minted}
\caption{KillBehavior}
\label{lst:asm:KillBehavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule MacroBehavior(MI) =
  let ch = channelFor(self),
     pID = processIDFor(self) in
  local remainingStates := activeStates(ch, MI) in
    seq
      macroExecutionState(ch, MI) := undef
    next
      // NOTE: can not be done with foreach, as remainingStates is modified
      while (|remainingStates| > 0) do
      let stateNumber = getAnyStateWithHighestPrio(pID, remainingStates) in
      seqblock
        executionState(ch, MI, stateNumber) := undef
        addStates(ch, MI, stateNumber)      := []
        removeStates(ch, MI, stateNumber)   := []

        Behavior(MI, stateNumber)

        // NOTE: mutates remainingStates!
        let state = executionState(ch, MI, stateNumber) in
          UpdateRemainingStates(MI, stateNumber, state, remainingStates)

        UpdateActiveStates(MI, stateNumber)
      endseqblock
\end{minted}
\caption{MacroBehavior}
\label{lst:asm:MacroBehavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule UpdateRemainingStates(MI, stateNumber, exState, remainingStates) =
  let ch = channelFor(self),
     pID = processIDFor(self) in
  if (exState = REPEAT) then {
    remainingStates := [stateNumber]

    macroExecutionState(ch, MI) := DONE

    // reset
    executionState(ch, MI, stateNumber) := undef
  }
  else if (exState = DONE) then {
    seq // end loop ...
      remainingStates := []
    next
      // ... but add new states of this MI to initialize them,
      // so that all states have the same start time
      foreach x in addStates(ch, MI, stateNumber)
        with nth(x, 1) = MI do {
        add nth(x, 2) to remainingStates
      }

    macroExecutionState(ch, MI) := DONE

    // quasi-reset
    executionState(ch, MI, stateNumber) := NEXT
  }
  else if (exState = NEXT) then {
    seq
      remove stateNumber from remainingStates // remove self
    next
      // reduce to states with same priority
      let prio = statePriority(pID, stateNumber) in
        remainingStates := filterStatesWithSamePrio(pID, remainingStates, prio)

    if (macroExecutionState(ch, MI) != DONE) then
      macroExecutionState(ch, MI) := NEXT
  }
  else if (exState = LOWER) then {
    remove stateNumber from remainingStates // remove self

    if (macroExecutionState(ch, MI) != DONE
        and macroExecutionState(ch, MI) != NEXT) then
      macroExecutionState(ch, MI) := LOWER
  }
\end{minted}
\caption{UpdateRemainingStates}
\label{lst:asm:UpdateRemainingStates}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule UpdateActiveStates(MI, stateNumber) =
  // NOTE: everything needs to be sequential,
  // as activeStates is a list and not a set
  let ch = channelFor(self) in seqblock
    foreach x in addStates(ch, MI, stateNumber) do
      let xMI = nth(x, 1),
          xN  = nth(x, 2) in {
        add xN to activeStates(ch, xMI)
      }

    addStates(ch, MI, stateNumber) := undef

    foreach x in removeStates(ch, MI, stateNumber) do
      let xMI = nth(x, 1),
          xN  = nth(x, 2) in {
        // remove one instance of xN, if any
        remove xN from activeStates(ch, xMI)

        ResetState(xMI, xN)
      }

    removeStates(ch, MI, stateNumber) := undef
  endseqblock
\end{minted}
\caption{UpdateActiveStates}
\label{lst:asm:UpdateActiveStates}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// whether the state should be aborted or not
derived abortState(MI, stateNumber) =
  ((timeoutActive(channelFor(self), MI, stateNumber) = true) or
  (cancelDecision(channelFor(self), MI, stateNumber) = true))
\end{minted}
\caption{abortState}
\label{lst:asm:abortState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Behavior(MI, currentStateNumber) =
 let s = currentStateNumber,
    ch = channelFor(self) in
  if (initializedState(ch, MI, s) != true) then
    StartState(MI, s)
  else if (abortState(MI, s) = true) then
    AbortState(MI, s)
  else if (completed(ch, MI, s) != true) then
    Perform(MI, s)
  else if (initializedSelectedTransition(ch, MI, s) != true) then
    StartSelectedTransition(MI, s)
  else
   let transitionNumber = selectedTransition(ch, MI, s) in
    if (transitionCompleted(ch, MI, t) != true) then
      PerformTransition(MI, s, t)
    else {
      Proceed(MI, s, targetStateNumber(processIDFor(self), t))
      SetExecutionState(MI, s, DONE)
    }
\end{minted}
\caption{Behavior}
\label{lst:asm:Behavior}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortState(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  if (abortionCompleted(ch, MI, s) != true) then
    Abort(MI, s)
  else {
    if (cancelDecision(ch, MI, s) = true) then {
      let t = outgoingCancelTransition(pID, s) in
      let target = targetStateNumber(pID, t) in {
        Proceed(MI, s, target)
      }
    }
    else if (timeoutActive(ch, MI, s) = true) then {
      let t = outgoingTimeoutTransition(pID, s) in
      let target = targetStateNumber(pID, t) in {
        Proceed(MI, s, target)
      }
    }

    SetExecutionState(MI, s, DONE)
  }
\end{minted}
\caption{AbortState}
\label{lst:asm:AbortState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartState(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  let sType     = stateType(pID, s) in seqblock
    InitializeCompletion(MI, s)
    abortionCompleted(ch, MI, s) := false

    ResetTimeout(MI, s)
    cancelDecision(ch, MI, s) := false

    DisableAllTransitions(MI, s)
    initializedSelectedTransition(ch, MI, s) := false

    wantInput(ch, MI, s) := {}

    case sType of
      "function"       : StartFunction(MI, s)
      "internalAction" : StartInternalAction(MI, s)
      "send"           : StartSend(MI, s)
      "receive"        : SetExecutionState(MI, s, LOWER)
      "end"            : SetExecutionState(MI, s, REPEAT) // directly to Perform w/o ASM step
    endcase

    initializedState(ch, MI, s) := true
  endseqblock
\end{minted}
\caption{StartState}
\label{lst:asm:StartState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ResetState(MI, stateNumber) =
  let ch = channelFor(self),
       s = stateNumber in {
    executionState(ch, MI, s) := undef

    initializedState(ch, MI, s) := undef

    completed(ch, MI, s) := undef
    abortionCompleted(ch, MI, s) := undef

    startTime(ch, MI, s) := undef
    timeoutActive(ch, MI, s) := undef

    cancelDecision(ch, MI, s) := undef

    selectedTransition(ch, MI, s) := undef

    let pID = processIDFor(self) in
    forall t in outgoingNormalTransitions(pID, s) do {
      exitCondition(ch, MI, t) := undef
      transitionCompleted(ch, MI, t) := undef
    }

    initializedSelectedTransition(ch, MI, s) := undef

    wantInput(ch, MI, s) := undef

    // StartSend
    receivers(ch, MI, s) := undef
    reservationsDone(ch, MI, s) := undef
    messageContent(ch, MI, s) := undef
  }
\end{minted}
\caption{ResetState}
\label{lst:asm:ResetState}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Perform(MI, currentStateNumber) =
  let pID = processIDFor(self)
        s = currentStateNumber in
  case stateType(pID, s) of
    "function"       : PerformFunction(MI, s)
    "internalAction" : PerformInternalAction(MI, s)
    "send"           : PerformSend(MI, s)
    "receive"        : PerformReceive(MI, s)
    "end"            : PerformEnd(MI, s)
  endcase
\end{minted}
\caption{Perform}
\label{lst:asm:Perform}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectTransition(MI, currentStateNumber) =
  let ch = channelFor(self),
     s = currentStateNumber in
  if (|outgoingEnabledTransitions(ch, MI, s)| = 0) then
    // BLOCKED: none to select
    SetExecutionState(MI, s, NEXT)
  else if (not(contains(wantInput(ch, MI, s),
                        "TransitionDecision"))) then {
    add "TransitionDecision" to wantInput(ch, MI, s)
    SetExecutionState(MI, s, DONE)
  }
  else
    // waiting for selectedTransition
    SetExecutionState(MI, s, NEXT)
\end{minted}
\caption{SelectTransition}
\label{lst:asm:SelectTransition}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartSelectedTransition(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    let t = selectedTransition(ch, MI, s) in {
      InitializeCompletionTransition(MI, t)
      initializedSelectedTransition(ch, MI, s) := true
    }

    SetExecutionState(MI, s, REPEAT)
  }
\end{minted}
\caption{StartSelectedTransition}
\label{lst:asm:StartSelectedTransition}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransition(MI, currentStateNumber, t) =
  let pID = processIDFor(self),
        s = currentStateNumber in
  case stateType(pID, s) of
    "function"       : PerformTransitionFunction(MI, s, t)
    "internalAction" : SetCompletedTransition(MI, s, t)
    "send"           : PerformTransitionSend(MI, s, t)
    "receive"        : PerformTransitionReceive(MI, s, t)
  endcase
\end{minted}
\caption{PerformTransition}
\label{lst:asm:PerformTransition}
\end{listing}



\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Proceed(MI, s_from, s_to) = {
  AddState(MI, s_from, MI, s_to)
  RemoveState(MI, s_from, MI, s_from)
}
\end{minted}
\caption{Proceed}
\label{lst:asm:Proceed}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartTimeout(MI, currentStateNumber) = {
  startTime(channelFor(self), MI, currentStateNumber) := nanoTime()
  timeoutActive(channelFor(self), MI, currentStateNumber) := false
}

rule ResetTimeout(MI, currentStateNumber) = {
  startTime(channelFor(self), MI, currentStateNumber) := undef
  timeoutActive(channelFor(self), MI, currentStateNumber) := undef
}

rule ActivateTimeout(MI, currentStateNumber) = {
  timeoutActive(channelFor(self), MI, currentStateNumber) := true
}

rule InitializeCompletion(MI, currentStateNumber) = {
  completed(channelFor(self), MI, currentStateNumber) := false
}

rule SetCompleted(MI, currentStateNumber) = {
  SetExecutionState(MI, currentStateNumber, REPEAT)
  completed(channelFor(self), MI, currentStateNumber) := true
}

rule SetAbortionCompleted(MI, currentStateNumber) = {
  SetExecutionState(MI, currentStateNumber, DONE)
  abortionCompleted(channelFor(self), MI, currentStateNumber) := true
}


rule EnableTransition(MI, t) = {
  exitCondition(channelFor(self), MI, t) := true
}

rule EnableAllTransitions(MI, currentStateNumber) = {
  forall t in outgoingNormalTransitions(processIDFor(self), currentStateNumber) do {
    EnableTransition(MI, t)
  }
}


rule DisableTransition(MI, currentStateNumber, t) = {
  exitCondition(channelFor(self), MI, t) := false
}

rule DisableAllTransitions(MI, currentStateNumber) = {
  selectedTransition(channelFor(self), MI, currentStateNumber) := undef

  forall t in outgoingNormalTransitions(processIDFor(self), currentStateNumber) do {
    DisableTransition(MI, currentStateNumber, t)
  }
}

rule InitializeCompletionTransition(MI, t) = {
  transitionCompleted(channelFor(self), MI, t) := false
}


rule SetCompletedTransition(MI, currentStateNumber, t) = {
  SetExecutionState(MI, currentStateNumber, REPEAT)

  transitionCompleted(channelFor(self), MI, t) := true
}
\end{minted}
\caption{StartTimeout}
\label{lst:asm:StartTimeout}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartInternalAction(MI, currentStateNumber) = {
  StartTimeout(MI, currentStateNumber)

  EnableAllTransitions(MI, currentStateNumber)

  SetExecutionState(MI, currentStateNumber, LOWER)
}
\end{minted}
\caption{StartInternalAction}
\label{lst:asm:StartInternalAction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformInternalAction(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
    if (shouldTimeout(ch, MI, s) = true) then {
      SetCompleted(MI, s)
      ActivateTimeout(MI, s)
    }
    else if (selectedTransition(ch, MI, s) != undef) then
      SetCompleted(MI, s)
    else
      SelectTransition(MI, s)
\end{minted}
\caption{PerformInternalAction}
\label{lst:asm:PerformInternalAction}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartFunction(MI, currentStateNumber) =
  let pID = processIDFor(self) in
  let functionName = stateFunction(pID, currentStateNumber) in {
    StartTimeout(MI, currentStateNumber)

    if (startFunction(functionName) = undef) then
      skip
    else
      call startFunction(functionName) (MI, currentStateNumber)

    SetExecutionState(MI, currentStateNumber, LOWER)
  }
\end{minted}
\caption{StartFunction}
\label{lst:asm:StartFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformFunction(MI, currentStateNumber) =
  let s = currentStateNumber in
    if (shouldTimeout(channelFor(self), MI, s) = true) then {
      SetCompleted(MI, s)
      ActivateTimeout(MI, s)
    }
    else
      let pID = processIDFor(self) in
      let functionName = stateFunction(pID, s),
          args         = stateFunctionArguments(pID, s) in
        call performFunction(functionName) (MI, s, args)
\end{minted}
\caption{PerformFunction}
\label{lst:asm:PerformFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortFunction(MI, currentStateNumber) =
  let pID = processIDFor(self) in
  let functionName = stateFunction(pID, currentStateNumber) in
    if (abortFunction(functionName) = undef) then
      SetAbortionCompleted(MI, currentStateNumber)
    else
      // must set abortionCompleted eventually
      call abortFunction(functionName) (MI, currentStateNumber)
\end{minted}
\caption{AbortFunction}
\label{lst:asm:AbortFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionFunction(MI, currentStateNumber, t) =
  let pID = processIDFor(self),
        s = currentStateNumber in
  let functionName = stateFunction(pID, s) in
    if (performTransitionFunction(functionName) = undef) then
      SetCompletedTransition(MI, s, t)
    else
      call performTransitionFunction(functionName) (MI, s, t)
\end{minted}
\caption{PerformTransitionFunction}
\label{lst:asm:PerformTransitionFunction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SetCompletedAction(MI, currentStateNumber, res) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    if (res = undef) then
      choose t in outgoingNormalTransitions(pID, s) do
        selectedTransition(ch, MI, s) := t
    else
      let t = getTransitionByLabel(pID, s, res) in
        selectedTransition(ch, MI, s) := t

    SetCompleted(MI, s)
  }
\end{minted}
\caption{SetCompletedAction}
\label{lst:asm:SetCompletedAction}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartSend(MI, currentStateNumber) = {
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  // there must be exactly one transition
  let  t = first_outgoingNormalTransition(pID, s) in {
    receivers(ch, MI, s) := undef
    reservationsDone(ch, MI, s) := {}
    let mcVName = messageContentVar(pID, t) in
      messageContent(ch, MI, s) := loadVar(MI, mcVName)

    let cIDVName = messageNewCorrelationVar(pID, t) in
      if (cIDVName != undef and cIDVName != "") then {
        // FIXME: it's a bad idea to save the cID early and read
        // this variable later: it might get changed in the meantime
        SetVar(MI, cIDVName, "CorrelationID", nextCorrelationID)

        nextCorrelationID := nextCorrelationID + 1
        // ensure no other agent increments nextCorrelationID
        nextCorrelationIDUsedBy(nextCorrelationID) := self
      }
  }

  SetExecutionState(MI, s, LOWER)
}
\end{minted}
\caption{StartSend}
\label{lst:asm:StartSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformSend(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
  if (receivers(ch, MI, s) = undef) then
    SelectReceivers(MI, s)
  else if (messageContent(ch, MI, s) = undef) then
    SetMessageContent(MI, s)
  else if (startTime(ch, MI, s) = undef) then {
    StartTimeout(MI, s)
    SetExecutionState(MI, s, REPEAT)
  }
  else if (|receivers(ch, MI, s)| =
           |reservationsDone(ch, MI, s)|) then
    TryCompletePerformSend(MI, s)
  else if (shouldTimeout(ch, MI, s) = true) then {
    SetCompleted(MI, s)
    ActivateTimeout(MI, s)
  }
  else
    DoReservations(MI, s)
\end{minted}
\caption{PerformSend}
\label{lst:asm:PerformSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule TryCompletePerformSend(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  if (anyNonProperTerminated(receivers(ch, MI, s)) = true) then
    // BLOCKED: a receiver where a reservation was placed has
    // terminated non-proper in the meantime, refusing to continue
    if (shouldTimeout(ch, MI, s) = true) then {
      SetCompleted(MI, s)
      ActivateTimeout(MI, s)
    }
    else
      SetExecutionState(MI, s, NEXT)
  else {
    // there must be exactly one transition
    let t = first_outgoingNormalTransition(pID, s) in
      selectedTransition(ch, MI, s) := t

    SetCompleted(MI, s)
  }
\end{minted}
\caption{TryCompletePerformSend}
\label{lst:asm:TryCompletePerformSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectReceivers(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  // there must be exactly one transition
  let t = first_outgoingNormalTransition(pID, s) in
  let min = messageSubjectCountMin(pID, t),   // 0 => ALL
      max = messageSubjectCountMax(pID, t) in // 0 => no limit
    let recVName = messageSubjectVar(pID, t) in
    if (recVName != undef and recVName != "") then
      let rChs = loadChannelsFromVariable(MI, recVName, messageSubjectId(pID, t)) in
        if (|rChs| = 0 or (min != 0 and |rChs| < min)) then
          // BLOCKED: not enough receivers given
          SetExecutionState(MI, s, NEXT)
        else if (max != 0 and |rChs| > max)  then
          // too many receivers given -> call VarMan-Selection
          SelectReceivers_Selection(MI, s, rChs, min, max)
        else {
          // receivers fit min/max -> use them
          receivers(ch, MI, s) := rChs
          SetExecutionState(MI, s, REPEAT)
        }
    else // no variable with receivers -> call SelectAgents
      if (selectAgentsResult(ch, MI, s) != undef) then
        let y = selectAgentsResult(ch, MI, s) in {
          receivers(ch, MI, s) := y
          selectAgentsResult(ch, MI, s) := undef // reset

          SetExecutionState(MI, s, REPEAT)
        }
      else
        let sIDLocal = messageSubjectId(pID, t) in
          SelectAgents(MI, s, sIDLocal, min, max)
\end{minted}
\caption{SelectReceivers}
\label{lst:asm:SelectReceivers}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectReceivers_Selection(MI, currentStateNumber, rChs, min, max) =
  let ch = channelFor(self),
       s = currentStateNumber in
  let res = selectionResult(ch, MI, s) in
  if (res = undef) then
    let src = ["ChannelInformation", rChs] in
      Selection(MI, s, src, min, max)
  else {
    selectionResult(ch, MI, s) := undef
    receivers(ch, MI, s) := res

    SetExecutionState(MI, s, REPEAT)
  }
\end{minted}
\caption{SelectReceivers_Selection}
\label{lst:asm:SelectReceivers_Selection}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortSend(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    foreach r in reservationsDone(ch, MI, s) do {
      CancelReservation(MI, s, r)
    }

    SetAbortionCompleted(MI, s)
  }
\end{minted}
\caption{AbortSend}
\label{lst:asm:AbortSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionSend(MI, currentStateNumber, t) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in {
    let storeVName = messageStoreReceiverVar(pID, t) in
      if (storeVName != undef and storeVName != "") then
        SetVar(MI, storeVName, "ChannelInformation",
          reservationsDone(ch, MI, s))

    foreach r in reservationsDone(ch, MI, s) do {
      ReplaceReservation(MI, s, r)

      EnsureRunning(r)
    }

    SetCompletedTransition(MI, s, t)
  }
\end{minted}
\caption{PerformTransitionSend}
\label{lst:asm:PerformTransitionSend}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SetMessageContent(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
    if not(contains(wantInput(ch, MI, ch),
                    "MessageContentDecision")) then {
      add "MessageContentDecision" to wantInput(ch, MI, ch)
      SetExecutionState(MI, ch, DONE)
    }
    else
      // waiting for messageContent
      SetExecutionState(MI, ch, NEXT)
\end{minted}
\caption{SetMessageContent}
\label{lst:asm:SetMessageContent}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// handle all receivers
rule DoReservations(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
  local hasPlacedReservation := false in
    seq
      let receiversTodo = (receivers(ch, MI, s) diff
                           reservationsDone(ch, MI, s)) in
      foreach receiver in receiversTodo do
        local tmp := false in
          seq
            // result is true if a reservation was made
            tmp <- DoReservation(MI, s, receiver)
          next if (tmp = true) then
            hasPlacedReservation := true
    next
      if (hasPlacedReservation = true) then
        // reservation(s) placed, make update
        SetExecutionState(MI, s, DONE)
      else
        // no reservations made, allow other states
        SetExecutionState(MI, s, NEXT)
\end{minted}
\caption{DoReservations}
\label{lst:asm:DoReservations}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// handle single reservation
// result true if hasPlacedReservation, adds to reservationsDone
rule DoReservation(MI, currentStateNumber, receiverChannel) =
  if (properTerminated(receiverChannel) = true) then
    let pID = processIDFor(self) in
    // there must be exactly one transition
    let t   = first_outgoingNormalTransition(pID, currentStateNumber),
        senderChannel      = channelFor(self),
        receiverProcessID  = processIDOf(receiverChannel) in
    let senderSubjectID    = searchSenderSubjectID(pID, subjectIDFor(self), receiverProcessID),
        msgCorrelationID   = loadCorrelationID(MI, messageNewCorrelationVar(pID, t)),
        ipCorrelationID    = loadCorrelationID(MI, messageWithCorrelationVar(pID, t)) in
    let reservationMessage = [senderChannel, messageType(pID, t), {}, msgCorrelationID, true] in
      seq
        // prepare receiver IP
        if (inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) = undef) then {
          add [senderSubjectID, messageType(pID, t), ipCorrelationID] to inputPoolDefined(receiverChannel)
          inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) := []
        }
      next
        if (inputPoolIsClosed(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) != true) then
          if (inputPoolGetFreeSpace(receiverChannel, senderSubjectID, messageType(pID, t)) > 0) then {
            enqueue reservationMessage into inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID)
            add receiverChannel to reservationsDone(channelFor(self), MI, currentStateNumber)
            result := true
          }
          else
            result := false // BLOCKED: no free space!
        else
          result := false // BLOCKED: inputPoolIsClosed
  else
    result := false // BLOCKED: non-properTerminated
\end{minted}
\caption{DoReservation}
\label{lst:asm:DoReservation}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CancelReservation(MI, currentStateNumber, receiverChannel) =
  let pID = processIDFor(self) in
  let t   = first_outgoingNormalTransition(pID, currentStateNumber),
      senderChannel      = channelFor(self),
      receiverProcessID  = processIDOf(receiverChannel) in
  let senderSubjectID    = searchSenderSubjectID(pID, subjectIDFor(self), receiverProcessID),
      msgCorrelationID   = loadCorrelationID(MI, messageNewCorrelationVar(pID, t)),
      ipCorrelationID    = loadCorrelationID(MI, messageWithCorrelationVar(pID, t)) in
  let reservationMessage = [senderChannel, messageType(pID, t), {}, msgCorrelationID, true],
      IP = inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) in
    inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) := dropnth(IP, head(indexes(IP, reservationMessage)))
\end{minted}
\caption{CancelReservation}
\label{lst:asm:CancelReservation}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ReplaceReservation(MI, currentStateNumber, receiverChannel) = {
  let pID = processIDFor(self) in
  let t   = first_outgoingNormalTransition(pID, currentStateNumber),
      senderChannel      = channelFor(self),
      receiverProcessID  = processIDOf(receiverChannel) in
  let senderSubjectID    = searchSenderSubjectID(pID, subjectIDFor(self), receiverProcessID),
      msgCorrelationID   = loadCorrelationID(MI, messageNewCorrelationVar(pID, t)),
      ipCorrelationID    = loadCorrelationID(MI, messageWithCorrelationVar(pID, t)) in
  let reservationMessage = [senderChannel, messageType(pID, t), {}, msgCorrelationID, true],
      message            = [senderChannel, messageType(pID, t), messageContent(channelFor(self), MI, currentStateNumber), msgCorrelationID, false],
      IP = inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) in {
      // TODO: discuss: setnth or dropnth & enqueue?
      inputPool(receiverChannel, senderSubjectID, messageType(pID, t), ipCorrelationID) := setnth(IP, head(indexes(IP, reservationMessage)), message)
  }
}
\end{minted}
\caption{ReplaceReservation}
\label{lst:asm:ReplaceReservation}
\end{listing}





\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformReceive(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  // startTime must be the time of the first attempt to receive
  // in order to support receiving with timeout=0
  if (startTime(ch, MI, s) = undef) then {
    StartTimeout(MI, s)
    SetExecutionState(MI, s, REPEAT)
  }
  else if (shouldTimeout(ch, MI, s) = true) then {
    SetCompleted(MI, s)
    ActivateTimeout(MI, s)
  }
  else
    seq
      forall t in outgoingNormalTransitions(pID, s) do
        CheckIP(MI, s, t)
    next
      let enabledT = outgoingEnabledTransitions(ch, MI, s) in
      if (|enabledT| > 0) then
        seq
          if (selectedTransition(ch, MI, s) != undef) then
            skip // there is already an transition selected
          else if (|enabledT| = 1) then
            let t = firstFromSet(enabledT) in
            if (transitionIsAuto(pID, t) = true) then
              // make automatic decision
              selectedTransition(ch, MI, s) := t
            else skip // can not make automatic decision
          else skip // can not make automatic decision
        next
          if (selectedTransition(ch, MI, s) != undef) then
            // the decision was made
            SetCompleted(MI, s)
          else
            // no decision made, waiting for selectedTransition
            SelectTransition(MI, s)
      else
        SetExecutionState(MI, s, LOWER) // BLOCKED: no messages
\end{minted}
\caption{PerformReceive}
\label{lst:asm:PerformReceive}
\end{listing}


\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionReceive(MI, currentStateNumber, t) =
  ReceiveMessage(MI, currentStateNumber, t)
\end{minted}
\caption{PerformTransitionReceive}
\label{lst:asm:PerformTransitionReceive}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ReceiveMessage(MI, currentStateNumber, transitionNumber) = {
  let pID   = processIDFor(self) in
  let s           = messageSubjectId         (pID, transitionNumber),
      sChsVName = messageSubjectVar        (pID, transitionNumber),
      mt          = messageType              (pID, transitionNumber),
      cIDVName  = messageWithCorrelationVar(pID, transitionNumber) in
  // TODO 2019-02-22: local receivedMessages ? Or is that function used elsewhere?
  // Alternative: directly return as listres via result in InputPool_Pop?
  local stringres1, // subjectID
      setres1,    // subjectChannels
      stringres2, // messageType
      numres1 in  // correlationID
  seqblock

      debuginfo ReceiveMessage self + ": ReceiveMessage in state " + statePretty(MI, currentStateNumber) + " with transition " + transitionPretty(MI, transitionNumber)

      // TODO/NOTE: same structure as CheckIP. May refactor to reduce duplicated code?

      if (s = "*") then {
        debuginfo ReceiveMessage self + ": wildcard for subject is ? and not *"
        Crash()
      }
      else if (s = "?") then {
        stringres1 := undef
      }
      else {
        stringres1 := s
      }


      if (sChsVName = undef or sChsVName = "") then {
        setres1 := undef
      }
      else {
        seq
          setres1 := loadChannelsFromVariable(MI, sChsVName, s) // (stringres1 would be fine too)
        next
          debuginfo CheckIP self + ": considering only messages from the following channels: " + setres1
      }


      if (mt = "*") then {
        debuginfo ReceiveMessage self + ": wildcard for message type is ? and not *"
        Crash()
      }
      else if (mt = "?") then {
        stringres2 := undef
      }
      else {
        stringres2 := mt
      }


      if (cIDVName = "*") then {
        debuginfo ReceiveMessage self + ": wildcard for cID type is ? and not *"
        Crash()
      }
      else if (cIDVName = "?") then {
        numres1 := undef
      }
      else {
        numres1 := loadCorrelationID(MI, cIDVName)
      }



      let sL    = stringres1,
        sChsL = setres1,
        mtL   = stringres2,
        cL    = numres1,
        countMinL = messageSubjectCountMin(pID, transitionNumber),
        countMaxL = messageSubjectCountMax(pID, transitionNumber) in {
        // InputPool_Pop stores the popped messages in receivedMessages
        // undef is wildcard
        InputPool_Pop(MI, currentStateNumber, sL, sChsL, mtL, cL, countMinL, countMaxL)
      }

      let msgs = receivedMessages(channelFor(self), MI, currentStateNumber) in {
        debuginfo ReceiveMessage self + ": receivedMessages: " + msgs

        if (messageStoreMessagesVar(pID, transitionNumber) != undef and messageStoreMessagesVar(pID, transitionNumber) != "") then {
          let vName = messageStoreMessagesVar(pID, transitionNumber) in {
              SetVar(MI, vName, "MessageSet", msgs)
          }
        }
      }

      SetCompletedTransition(MI, currentStateNumber, transitionNumber) // sets executionState to REPEAT
  endseqblock
}
\end{minted}
\caption{ReceiveMessage}
\label{lst:asm:ReceiveMessage}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CheckIP(MI, currentStateNumber, transitionNumber) = {
  let pID   = processIDFor(self) in
  let sID         = messageSubjectId         (pID, transitionNumber),
      sChsVName = messageSubjectVar        (pID, transitionNumber),
      mT          = messageType              (pID, transitionNumber),
      cIDVName  = messageWithCorrelationVar(pID, transitionNumber) in
  local stringres1, // subjectID
      setres1,    // subjectChannels
      stringres2, // messageType
      numres1 in  // correlationID
  seqblock

      // TODO/NOTE: same structure as ReceiveMessage. May refactor to reduce duplicated code?

      if (sID = "?") then {
        stringres1 := undef
      }
      else if (sID = "*") then {
        debuginfo CheckIP self + ": subject wildcard is '?'"
        Crash()
      }
      else {
        stringres1 := sID
      }


      if (sChsVName = undef or sChsVName = "") then {
        setres1 := undef
      }
      else {
        seq
          setres1 := loadChannelsFromVariable(MI, sChsVName, sID) // (stringres1 would be fine too)
        next
          debuginfo CheckIP self + ": considering only messages from the following channels: " + setres1
      }


      if (mT = "?") then {
        stringres2 := undef
      }
      else if (mT = "*") then {
        debuginfo CheckIP self + ": message type wildcard is '?'"
        Crash()
      }
      else {
        stringres2 := mT
      }


      if (cIDVName = "?") then {
        numres1 := undef
      }
      else if (cIDVName = "*") then {
        debuginfo CheckIP self + ": correlationID wildcard is '?'"
        Crash()
      }
      else {
        numres1 := loadCorrelationID(MI, messageWithCorrelationVar(pID, transitionNumber))
      }


      // no reservations, supress multiple channels
      let usedSpace = inputPoolUsedSpace(channelFor(self), stringres1, setres1, stringres2, numres1, true, true) in {
        if (messageSubjectCountMin(pID, transitionNumber) = 0) then {
          if (usedSpace > |setres1|) then {
              debuginfo CheckIP self + ": WARN: internal error: more messages than expected senders! " + usedSpace + " > " + |setres1|
              Crash()
          }
          else if (usedSpace = |setres1|) then {
              debuginfo CheckIP self + ": enough messages :) " + usedSpace + " = " + |setres1|
              EnableTransition(MI, transitionNumber)
          }
          else {
              debuginfo CheckIP self + ": Not enough messages: " + usedSpace + " < " + |setres1|
              DisableTransition(MI, currentStateNumber, transitionNumber)
          }
        }
        else if (usedSpace >= messageSubjectCountMin(pID, transitionNumber)) then {
          debuginfo CheckIP self + ": enough messages :) " + usedSpace + " >= " + messageSubjectCountMin(pID, transitionNumber)
          EnableTransition(MI, transitionNumber)
        }
        else {
          debuginfo CheckIP self + ": Not enough messages: " + usedSpace + " < " + messageSubjectCountMin(pID, transitionNumber)
          DisableTransition(MI, currentStateNumber, transitionNumber)
        }
      }
  endseqblock
}
\end{minted}
\caption{CheckIP}
\label{lst:asm:CheckIP}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformEnd(MI, currentStateNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  if (|activeStates(ch, MI)| > 1) then {
    // does not remove currentStateNumber
    AbortMacroInstance(MI, s)
    SetExecutionState(MI, s, DONE)
  }
  else {
    if (MI = 1) then { // terminate subject
      ClearAllVarInMI(ch, 0)
      ClearAllVarInMI(ch, 1)

      FinalizeInteraction()

      program(self) := undef
      remove self from asmAgents
    }
    else { // terminate only Macro Instance
      ClearAllVarInMI(ch, MI)

      let res = head(stateFunctionArguments(pID, s)) in
      if (res != undef) then
        // use parameter as result for CallMacro State
        macroTerminationResult(ch, MI) := res
      else
        // just indicate termination
        macroTerminationResult(ch, MI) := true
    }

    // remove self
    RemoveState(MI, s, MI, s)
    SetExecutionState(MI, s, DONE)
  }
\end{minted}
\caption{PerformEnd}
\label{lst:asm:PerformEnd}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule StartTau(MI, currentStateNumber) =
  EnableAllTransitions(MI, currentStateNumber)

rule Tau(MI, currentStateNumber, args) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
    choose t in outgoingEnabledTransitions(t, MI, s)
        with (transitionIsAuto(pID, t) = true) do {
      selectedTransition(t, MI, s) := t
      SetCompleted(MI, s)
    }
    ifnone // WARN: unable to choose auto transition!
      if (selectedTransition(t, MI, s) != undef) then
        SetCompleted(MI, s)
      else
        SelectTransition(MI, s)
\end{minted}
\caption{Tau}
\label{lst:asm:Tau}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortVarMan(MI, currentStateNumber) = {
  ResetSelection(MI, currentStateNumber)
  SetAbortionCompleted(MI, currentStateNumber)
}

rule VarMan(MI, currentStateNumber, args) = {
  let method = head(args) in {
      debuginfo VarMan self + ": method: " + method
      debuginfo VarMan self + ": args: " + tail(args)

      case method of
        "assign"                : VarMan_Assign               (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "storeData"             : VarMan_StoreData            (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "clear"                 : VarMan_Clear                (MI, currentStateNumber, nth(args, 2))

        "concatenation"         : VarMan_Concatenation        (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4))
        "intersection"          : VarMan_Intersection         (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4))
        "difference"            : VarMan_Difference           (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4))

        "extractContent"        : VarMan_ExtractContent       (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "extractChannel"        : VarMan_ExtractChannel       (MI, currentStateNumber, nth(args, 2), nth(args, 3))
        "extractCorrelationID"  : VarMan_ExtractCorrelationID (MI, currentStateNumber, nth(args, 2), nth(args, 3))

        "selection"             : VarMan_Selection            (MI, currentStateNumber, nth(args, 2), nth(args, 3), nth(args, 4), nth(args, 5))
      endcase
  }
}


rule VarMan_Assign(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
      SetVar(MI, X, head(a), last(a))

      SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
  }
}

rule VarMan_StoreData(MI, currentStateNumber, X, A) = {
  SetVar(MI, X, "Data", A)

  SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
}

rule VarMan_Clear(MI, currentStateNumber, X) = {
  ClearVar(MI, X)

  SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
}

rule VarMan_Concatenation(MI, currentStateNumber, A, B, X) = {
  let a = loadVar(MI, A),
      b = loadVar(MI, B) in {
      if (a = undef and b = undef) then {
        ClearVar(MI, X)

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (a = undef) then {
        SetVar(MI, X, head(b), last(b))

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (b = undef) then {
        SetVar(MI, X, head(a), last(a))

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (head(a) != head(b) or not(contains({"MessageSet", "ChannelInformation"}, head(a)))) then {
        debuginfo VarMan_Concatenation self + ": invalid parameters"

        Crash()
      }
      else {
        let x = (last(a) union last(b)) in {
          SetVar(MI, X, head(a), x)

          SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
        }
      }
  }
}

rule VarMan_Intersection(MI, currentStateNumber, A, B, X) = {
  let a = loadVar(MI, A) in
  let b = loadVar(MI, B) in {
      if (a = undef or b = undef) then {
        ClearVar(MI, X)

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (head(a) != head(b) or not(contains({"MessageSet", "ChannelInformation"}, head(a)))) then {
        debuginfo VarMan_Intersection self + ": invalid parameters"
        debuginfo VarMan_Intersection self + ": A = " + undefStr(A)
        debuginfo VarMan_Intersection self + ": a = " + undefStr(a)
        debuginfo VarMan_Intersection self + ": B = " + undefStr(B)
        debuginfo VarMan_Intersection self + ": b = " + undefStr(b)

        Crash()
      }
      else {
        let x = (last(a) intersect last(b)) in {
          SetVar(MI, X, head(a), x)

          SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
        }
      }
  }
}

rule VarMan_Difference(MI, currentStateNumber, A, B, X) = {
  let a = loadVar(MI, A) in
  let b = loadVar(MI, B) in {
      if (a = undef) then {
        ClearVar(MI, X)

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (b = undef) then {
        SetVar(MI, X, head(a), last(a))

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
      else if (head(a) != head(b) or not(contains({"MessageSet", "ChannelInformation"}, head(a)))) then {
        debuginfo VarMan_Difference self + ": invalid parameters"
        debuginfo VarMan_Difference self + ": A = " + undefStr(A)
        debuginfo VarMan_Difference self + ": a = " + undefStr(a)
        debuginfo VarMan_Difference self + ": B = " + undefStr(B)
        debuginfo VarMan_Difference self + ": b = " + undefStr(b)

        Crash()
      }
      else {
        let x = (last(a) diff last(b)) in {
          SetVar(MI, X, head(a), x)

          SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
        }
      }
  }
}


rule VarMan_ExtractContent(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
    // TODO: How to deal with empty / undef variables?
    if (head(a) != "MessageSet") then {
      debuginfo VarMan_ExtractContent self + ": invalid parameter"
      debuginfo VarMan_ExtractContent self + ": A = " + undefStr(A)
      debuginfo VarMan_ExtractContent self + ": a = " + undefStr(a)

      Crash()
    }
    else {
      let messages = last(a) in
      let messagesContent = map(messages, @msgContent) in {
        if (| messagesContent | = 0) then {
          debuginfo VarMan_ExtractContent self + ": no content to extract"
          Crash()
        }
        else if (| messagesContent | = 1) then {
          let content = firstFromSet(messagesContent) in {
            debuginfo VarMan_ExtractContent self + ": exact one content to extract: " + content
            SetVar(MI, X, head(content), last(content))
          }
        }
        else {
          // check if all contents have the same type, and that the type is union-able
          let x = firstFromSet(messagesContent) in {
            if (head(x) = "MessageSet" or head(x) = "ChannelInformation") then {
              // check if all are the same type
              if (forall y in messagesContent holds (head(y) = head(x))) then {
                debuginfo VarMan_ExtractContent self + ": flattening content: " + content
                SetVar(MI, X, head(x), flattenSet(map(messagesContent, @last)))
              }
              else {
                debuginfo VarMan_ExtractContent self + ": all messages must have the same underlying datatype!"
                debuginfo VarMan_ExtractContent self + ": messages: " + messages
                debuginfo VarMan_ExtractContent self + ": messagesContent: " + messagesContent

                Crash()
              }
            }
            else {
              debuginfo VarMan_ExtractContent self + ": invalid message content type, can not be merged: '" + head(x) + "'"

              Crash()
            }
          }
        }

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
    }
  }
}

rule VarMan_ExtractChannel(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
    // TODO: How to deal with empty / undef variables?
    if (head(a) != "MessageSet") then {
      debuginfo VarMan_ExtractChannel self + ": invalid parameter"
      debuginfo VarMan_ExtractChannel self + ": A = " + undefStr(A)
      debuginfo VarMan_ExtractChannel self + ": a = " + undefStr(a)

      Crash()
    }
    else {
      let messages = last(a) in
      let messagesChannel = map(messages, @msgChannel) in {
        if (| messagesChannel | = 0) then {
          debuginfo VarMan_ExtractChannel self + ": no channels to extract"
          Crash()
        }
        else {
          debuginfo VarMan_ExtractChannel self + ": messagesChannel: " + messagesChannel
          SetVar(MI, X, "ChannelInformation", messagesChannel)
        }

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
    }
  }
}

rule VarMan_ExtractCorrelationID(MI, currentStateNumber, A, X) = {
  let a = loadVar(MI, A) in {
    // TODO: How to deal with empty / undef variables?
    if (head(a) != "MessageSet") then {
      debuginfo VarMan_ExtractCorrelationID self + ": invalid parameter"
      debuginfo VarMan_ExtractCorrelationID self + ": A = " + undefStr(A)
      debuginfo VarMan_ExtractCorrelationID self + ": a = " + undefStr(a)

      Crash()
    }
    else {
      let messages = last(a) in
      let messagesCorrelationID = map(messages, @msgCorrelation) in {
        if (| messagesCorrelationID | != 1) then {
          debuginfo VarMan_ExtractCorrelationID self + ": a CorrelationID can only be extracted when there is exactly one, got: " + messagesCorrelationID
          Crash()
        }
        else {
          debuginfo VarMan_ExtractCorrelationID self + ": messagesCorrelationID: " + messagesCorrelationID
          SetVar(MI, X, "CorrelationID", firstFromSet(messagesCorrelationID))
        }

        SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
      }
    }
  }
}
\end{minted}
\caption{VarMan}
\label{lst:asm:VarMan}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// CH * MI * n
function selectionVartype  : LIST * NUMBER * NUMBER -> STRING
function selectionData     : LIST * NUMBER * NUMBER -> LIST
function selectionOptions  : LIST * NUMBER * NUMBER -> LIST
function selectionMin      : LIST * NUMBER * NUMBER -> NUMBER
function selectionMax      : LIST * NUMBER * NUMBER -> NUMBER
function selectionDecision : LIST * NUMBER * NUMBER -> SET

function selectionResult   : LIST * NUMBER * NUMBER -> SET

rule VarMan_Selection(MI, currentStateNumber, srcVName, dstVName, minimum, maximum) = {
  let src = loadVar(MI, srcVName),
    res = selectionResult(channelFor(self), MI, currentStateNumber) in
  if (res = undef) then {
    // TODO: cancel / timeout transition?
    Selection(MI, currentStateNumber, src, minimum, maximum)
  }
  else {
    selectionResult(channelFor(self), MI, currentStateNumber) := undef

    SetVar(MI, dstVName, head(src), res)

    SetCompletedAction(MI, currentStateNumber, undef) // sets executionState to REPEAT
  }
}

rule ResetSelection(MI, currentStateNumber) = {
  selectionVartype (channelFor(self), MI, currentStateNumber) := undef
  selectionData    (channelFor(self), MI, currentStateNumber) := undef
  selectionOptions (channelFor(self), MI, currentStateNumber) := undef
  selectionMin     (channelFor(self), MI, currentStateNumber) := undef
  selectionMax     (channelFor(self), MI, currentStateNumber) := undef
  selectionDecision(channelFor(self), MI, currentStateNumber) := undef
}

rule Selection(MI, currentStateNumber, src, minimum, maximum) = {
  if (selectionData(channelFor(self), MI, currentStateNumber) = undef) then {
      if (head(src) = "MessageSet") then {
        let l = toList(last(src)) in {
          selectionData   (channelFor(self), MI, currentStateNumber) := l
          selectionOptions(channelFor(self), MI, currentStateNumber) := map(l, @msgToString)
        }
      }
      else if (head(src) = "ChannelInformation") then {
        let l = toList(last(src)) in {
          selectionData   (channelFor(self), MI, currentStateNumber) := l
          selectionOptions(channelFor(self), MI, currentStateNumber) := map(l, @chToString)
        }
      }
      else {
        debuginfo Selection self + ": can not perform selection on datatype '" + head(x) + "'"

        Crash()
      }

      selectionVartype (channelFor(self), MI, currentStateNumber) := head(src)
      selectionMin     (channelFor(self), MI, currentStateNumber) := minimum
      selectionMax     (channelFor(self), MI, currentStateNumber) := maximum
      selectionDecision(channelFor(self), MI, currentStateNumber) := undef // just to be sure

      SetExecutionState(MI, currentStateNumber, REPEAT)
  }
  else if (selectionDecision(channelFor(self), MI, currentStateNumber) = undef) then {
      if not(contains(wantInput(channelFor(self), MI, currentStateNumber), "SelectionDecision")) then {
        add "SelectionDecision" to wantInput(channelFor(self), MI, currentStateNumber)

        SetExecutionState(MI, currentStateNumber, DONE)
      }
      else {
        debuginfo Selection self + ": waiting for selectionDecision"
        SetExecutionState(MI, currentStateNumber, NEXT)
      }
  }
  else {
      let res = pickItems(selectionData(channelFor(self), MI, currentStateNumber), selectionDecision(channelFor(self), MI, currentStateNumber)) in {
        selectionResult(channelFor(self), MI, currentStateNumber) := res
      }

      ResetSelection(MI, currentStateNumber)

      SetExecutionState(MI, currentStateNumber, REPEAT)
  }
}
\end{minted}
\caption{VarMan_Selection}
\label{lst:asm:VarMan_Selection}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule ModalSplit(MI, currentStateNumber, args) =
  let pID = processIDFor(self),
        s = currentStateNumber in {
  // start all following states
  foreach t in outgoingNormalTransitions(pID, s) do
    let sNew = targetStateNumber(pID, t) in
      AddState(MI, s, MI, sNew)

  // remove self
  RemoveState(MI, s, MI, s)

  SetExecutionState(MI, s, DONE)
}
\end{minted}
\caption{ModalSplit}
\label{lst:asm:ModalSplit}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * joinState -> Number
function joinCount : LIST * NUMBER * NUMBER -> NUMBER

// number of execution paths have to be provided as argument
rule ModalJoin(MI, currentStateNumber, args) =
  let ch = channelFor(self),
       s = currentStateNumber,
      numSplits = nth(args, 1) in
  seq // count how often this join has been called
    if (joinCount(ch, MI, s) = undef) then
      joinCount(ch, MI, s) := 1
    else
      joinCount(ch, MI, s) := joinCount(ch, MI, s) + 1
  next
    // can we continue, or remove self and will be called again?
    if (joinCount(ch, MI, s) < numSplits) then {
      // drop this execution path
      RemoveState(MI, s, MI, s)
      SetExecutionState(MI, s, DONE)
    }
    else {
      // reset for next iteration
      joinCount(ch, MI, s) := undef
      SetCompletedAction(MI, s, undef)
    }
\end{minted}
\caption{ModalJoin}
\label{lst:asm:ModalJoin}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule AbortCallMacro(MI, currentStateNumber) =
  let ch = channelFor(self),
       s = currentStateNumber in
  let childInstance = callMacroChildInstance(ch, MI, s) in
    if (|activeStates(ch, childInstance)| > 0) then {
      AbortMacroInstance(childInstance, undef)
      SetExecutionState(MI, s, DONE)
    }
    else {
      callMacroChildInstance(ch, MI, s) := undef
      SetAbortionCompleted(MI, s)
    }
\end{minted}
\caption{AbortCallMacro}
\label{lst:asm:AbortCallMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule InitializeMacroArguments(MI, mIDNew, MINew, givenSrcVNames) =
  local
      dstVNames := macroArguments(processIDFor(self), mIDNew),
      srcVNames := givenSrcVNames in
    while (|dstVNames| > 0) do {
      let dstVName = head(dstVNames),
          srcVName = head(srcVNames) in
      let var = loadVar(MI, srcVName) in
        SetVar(MINew, dstVName, nth(var, 1), nth(var, 2))

      dstVNames := tail(dstVNames)
      srcVNames := tail(srcVNames)
    }
\end{minted}
\caption{InitializeMacroArguments}
\label{lst:asm:InitializeMacroArguments}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CallMacro(MI, currentStateNumber, args) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  let childInstance = callMacroChildInstance(ch, MI, s) in
  if (childInstance = undef) then
    // start new Macro Instance
    let mIDNew = searchMacro(head(args)),
        MINew  = nextMacroInstanceNumber(ch) in
    seqblock
      nextMacroInstanceNumber(ch) := MINew + 1
      macroNumberOfMI(ch, MINew) := mIDNew
      callMacroChildInstance(ch, MI, s) := MINew

      if (|macroArguments(ch, mIDNew)| > 0) then
        InitializeMacroArguments(MI, mIDNew, MINew, tail(args))

      SetExecutionState(MI, s, DONE)

      StartMacro(MI, s, mIDNew, MINew)
    endseqblock
  else
    let childResult = macroTerminationResult(ch, childInstance) in
    if (childResult != undef) then {
      callMacroChildInstance(ch, MI, s) := undef

      // transport result, if present
      if (childResult = true) then
        SetCompletedAction(MI, s, undef)
      else
        SetCompletedAction(MI, s, childResult)
    }
    else seqblock
      // Macro Instance is active, call it...
      MacroBehavior(childInstance)

      // ... and transport its execution state
      let mState = macroExecutionState(ch, childInstance) in
        SetExecutionState(MI, s, mState)

      // reset
      macroExecutionState(ch, childInstance) := undef
    endseqblock
\end{minted}
\caption{CallMacro}
\label{lst:asm:CallMacro}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CheckCancel(MI, currentStateNumber, transitionNumber) =
  let ch = channelFor(self),
     pID = processIDFor(self) in
  let tName = transitionLabel(pID, transitionNumber) in
  let nCancel = stateNumberFromID(pID, tName) in
  if (contains(activeStates(ch, MI), nCancel) = true) then
    // referenced state is active in this Macro Instance
    EnableTransition(MI, transitionNumber)
  else
    DisableTransition(MI, currentStateNumber, transitionNumber)
\end{minted}
\caption{CheckCancel}
\label{lst:asm:CheckCancel}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule Cancel(MI, currentStateNumber, args) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
  seq
    forall t in outgoingNormalTransitions(pID, s) do
      CheckCancel(MI, s, t)
  next
    let enabledT = outgoingEnabledTransitions(ch, MI, s) in
    if (|enabledT| > 0) then
      seq
        if (|enabledT| = 1) then
          let t = firstFromSet(enabledT) in
          if (transitionIsAuto(pID, t) = true) then
            selectedTransition(ch, MI, s) := t
      next
        if (selectedTransition(ch, MI, s) != undef) then
          let t = selectedTransition(ch, MI, s) in
            SetCompletedAction(MI, s, transitionLabel(pID, t))
        else
          SelectTransition(MI, s)
    else // BLOCKED: no corresponding active states
      SetExecutionState(MI, s, LOWER)
\end{minted}
\caption{Cancel}
\label{lst:asm:Cancel}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule PerformTransitionCancel(MI, currentStateNumber, t) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber in
    let tLabel  = transitionLabel(pID, t) in
    let nCancel = stateNumberFromID(pID, tLabel) in {
      cancelDecision(ch, MI, nCancel) := true
      SetCompletedTransition(MI, s, t)
    }
\end{minted}
\caption{PerformTransitionCancel}
\label{lst:asm:PerformTransitionCancel}
\end{listing}






\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CloseIP(MI, currentStateNumber, args) =
  let ch = channelFor(self),
      senderSubjID       = nth(args, 1),
      messageType        = nth(args, 2),
      correlationIDVName = nth(args, 3) in
  let correlationID = loadCorrelationID(MI, correlationIDVName) in {
    inputPoolClosed(ch, senderSubjID, messageType, correlationID) := true

    if (inputPool(ch, senderSubjID, messageType, correlationID) = undef) then {
      add [senderSubjID, messageType, correlationID] to inputPoolDefined(ch)
      inputPool(ch, senderSubjID, messageType, correlationID) := []
    }

    SetCompletedAction(MI, currentStateNumber, undef)
  }
\end{minted}
\caption{CloseIP}
\label{lst:asm:CloseIP}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule OpenIP(MI, currentStateNumber, args) =
  let ch = channelFor(self),
      senderSubjID       = nth(args, 1),
      messageType        = nth(args, 2),
      correlationIDVName = nth(args, 3) in
  let correlationID = loadCorrelationID(MI, correlationIDVName) in {
    inputPoolClosed(ch, senderSubjID, messageType, correlationID) := false

    if (inputPool(ch, senderSubjID, messageType, correlationID) = undef) then {
        add [senderSubjID, messageType, correlationID] to inputPoolDefined(ch)
        inputPool(ch, senderSubjID, messageType, correlationID) := []
    }

    SetCompletedAction(MI, currentStateNumber, undef)
  }
\end{minted}
\caption{OpenIP}
\label{lst:asm:OpenIP}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule CloseAllIPs(MI, currentStateNumber, args) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    inputPoolClosed(ch, undef, undef, undef) := true

    forall key in inputPoolDefined(ch) do
      let sID = nth(key, 1),
          mT  = nth(key, 2),
          cID = nth(key, 3) in {
        inputPoolClosed(ch, sID, mT, cID) := true
      }

    SetCompletedAction(MI, s, undef)
  }
\end{minted}
\caption{CloseAllIPs}
\label{lst:asm:CloseAllIPs}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule OpenAllIPs(MI, currentStateNumber, args) =
  let ch = channelFor(self),
       s = currentStateNumber in {
    inputPoolClosed(ch, undef, undef, undef) := false

    forall key in inputPoolDefined(ch) do
      let sID = nth(key, 1),
          mT  = nth(key, 2),
          cID = nth(key, 3) in {
        inputPoolClosed(ch, sID, mT, cID) := false
      }

    SetCompletedAction(MI, s, undef)
  }
\end{minted}
\caption{OpenAllIPs}
\label{lst:asm:OpenAllIPs}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// correlation can be wildcard (*)
rule IsIPEmpty(MI, currentStateNumber, args) =
  let ch = channelFor(self),
       s = currentStateNumber,
     senderSubjID       = nth(args, 1),
     msgType            = nth(args, 2),
     correlationIDVName = nth(args, 3) in
  local cID in
    seq
      if (correlationIDVName = undef or
          correlationIDVName = 0 or
          correlationIDVName = "") then {
        cID := 0
      }
      else if (correlationIDVName = "*") then {
        cID := undef
      }
      else {
        cID := loadCorrelationID(MI, correlationIDVName)
      }
    next
      if inputPoolIsEmpty(ch, senderSubjID, msgType, cID) then
        SetCompletedAction(MI, s, "true")
      else
        SetCompletedAction(MI, s, "false")
\end{minted}
\caption{IsIPEmpty}
\label{lst:asm:IsIPEmpty}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
// Channel * MacroInstanceNumber * StateNumber -> BOOLEAN
function selectAgentsDecision : LIST * NUMBER * NUMBER -> SET

function selectAgentsProcessID : LIST * NUMBER * NUMBER -> STRING
function selectAgentsSubjectID : LIST * NUMBER * NUMBER -> STRING
function selectAgentsCountMin  : LIST * NUMBER * NUMBER -> NUMBER
function selectAgentsCountMax  : LIST * NUMBER * NUMBER -> NUMBER

function selectAgentsResult : LIST * NUMBER * NUMBER -> SET

rule SelectAgentsAction(MI, currentStateNumber, args) =
  let ch = channelFor(self),
       s = currentStateNumber,
      vName    = nth(args, 1),
      sIDLocal = nth(args, 2),
      countMin = nth(args, 3),
      countMax = nth(args, 4) in
    if (selectAgentsResult(ch, MI, s) != undef) then {
      SetVar(MI, vName, "ChannelInformation",
             selectAgentsResult(ch, MI, s))
      selectAgentsResult(ch, MI, s) := undef

      SetCompletedAction(MI, s, undef)
    }
    else
      SelectAgents(MI, s, sIDLocal, countMin, countMax)
\end{minted}
\caption{SelectAgentsAction}
\label{lst:asm:SelectAgentsAction}
\end{listing}




\begin{listing}[H]
\begin{minted}[fontsize=\small]{lexer.py:CoreASMLexer -x}
rule SelectAgents(MI, currentStateNumber, sIDLocal, min, max) =
  let ch = channelFor(self),
     pID = processIDFor(self),
       s = currentStateNumber,
      PI = processInstanceFor(self) in
  let givenAgents = predefinedAgents(pID, PI, sIDLocal),
      resolvedInterface = resolveInterfaceSubject(sIDLocal) in
  let resolvedProcessID = nth(resolvedInterface, 1),
      resolvedSubjectID = nth(resolvedInterface, 2) in
  if (selectAgentsDecision(ch, MI, s) != undef) then {
      local createdChannels := {} in
      seq
        foreach agent in selectAgentsDecision(ch, MI, s) do
          if (resolvedProcessID = pID) then
            // local process, use own PI
            let ch = [pID, PI, sIDLocal, agent] in {
              InitializeSubject(ch)
              add ch to createdChannels
            }
          else // external process, create new PI
            local newPI in
            seq
              newPI <- StartProcess(resolvedProcessID,
                                    resolvedSubjectID, agent)
            next
              add [resolvedProcessID, newPI,
                   resolvedSubjectID, agent] to createdChannels
      next
        selectAgentsResult(ch, MI, s) := createdChannels

      // reset for next iteration
      selectAgentsDecision (ch, MI, s) := undef
      selectAgentsCountMin (ch, MI, s) := undef
      selectAgentsCountMax (ch, MI, s) := undef
      selectAgentsProcessID(ch, MI, s) := undef
      selectAgentsSubjectID(ch, MI, s) := undef

      SetExecutionState(MI, s, REPEAT)
  }
  else if(hasSizeWithin(givenAgents, min, max) = true) then {
    selectAgentsDecision(ch, MI, s) := givenAgents
    SetExecutionState(MI, s, REPEAT)
  }
  else if not(contains(wantInput(ch, MI, s),
                       "SelectAgentsDecision")) then {
    add "SelectAgentsDecision" to wantInput(ch, MI, s)

    selectAgentsProcessID(ch, MI, s) := resolvedProcessID
    selectAgentsSubjectID(ch, MI, s) := resolvedSubjectID
    selectAgentsCountMin (ch, MI, s) := min
    selectAgentsCountMax (ch, MI, s) := max
    selectAgentsResult   (ch, MI, s) := undef

    SetExecutionState(MI, s, DONE)
  }
  else // waiting for selectAgentsDecision
    SetExecutionState(MI, s, NEXT)
\end{minted}
\caption{SelectAgents}
\label{lst:asm:SelectAgents}
\end{listing}
